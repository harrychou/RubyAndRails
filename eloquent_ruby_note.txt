Eloquent Ruby Note

===========================================================
PART I: The Basics 1
===========================================================

-----------------------------------------------------------
Chapter 1: Write Code That Looks Like Ruby 3
-----------------------------------------------------------

- use two spaces, never tabs

class Document
  attr_accessor :title, :author, :content

  def initialize(title, author, content) 
    @title = title
    @author = author
    @content = content
  end

  def words
    @content.split
  end 

  def word_count
    words.size 
  end
end

- oneliner comment is OK, if it adds more info

  return 0 if divisor == 0 # Avoid division by zero

- camels for Classes, snakes everywhere else
  
  * for constant:
  ALL_UPPER_CASE = 2

- parentheses? optional, but sometimes forbidden

  * most Ruby programmer do use parenthesis
  * but not for simple or common function calls, or calls without parameters

  puts 'Hello Word'

  def words
    @content.split
  end 

  * generally, don't use parenthesis for conditions in control statements

  if word.size > 100
    puts 'too long'
  end

- use semicolon to cram up multiple lines

  * generally, don't do it
  * only do it for simple places

  def method_to_be_overriden; end

- for code blocks (code between braces or use do ... end) 

  * for simeple one line code block, just fold it 

  10.times { |n| puts "The number is #{n}" }

  * for more than one line code block, use do ... end 
  
  10.times do |n|
    puts "The number is #{n}"
    puts "Twice the number is #{n*2}"
  end

-----------------------------------------------------------
Chapter 2: Choose the Right Control Structure 17
-----------------------------------------------------------

- If, Unless, While, and Until 17
  
  * if this then do that
  * do this unless that

  * 'if' is revers of 'unless'
    - 'if not xxx' is the same as 'unless xxx'
    - unless sometimess take less mental energy to process

  * if <--> unless
    while <--> until
  * ruby uses every opportunities to improve the 'readability' of the code

- Use the Modifier Forms Where Appropriate 19

  * do_something if xxx
  * do_something unless xxx
  * do_something while xxx
  * do_something until xxx
  * this is call 'Modifier form'

- Use each, Not for 20

  * in other languages, we use 'for'; for ruby, use 'each'

  fonts = [ 'courier', 'times roman', 'helvetica' ]

  for font in fonts
    puts font
  end  

  # same as
  fonts.each { |font| puts font }
  # or
  fonts.each do |font| 
    puts font 
  end

  * Ruby actually defines the for loop in terms of the each method:

- A Case of Programming Logic 21

    # used as switch statement
    title = 'Clean Code'
    case title
    when 'War And Peace'
      puts 'Tolstoy'
    when 'Romeo And Juliet'
      puts 'Shakespeare'
    else
      puts "Don't know"
    end

    # used to assign value
    author = case title
             when 'War And Peace'
               'Tolstoy'
             when 'Romeo And Juliet'
               'Shakespeare'
             else
               "Don't know"
             end
    expect(author).to eq("Don't know")

    # meke it more compact
    author = case title
             when 'War And Peace' then 'Tolstoy'
             when 'Romeo And Juliet' then 'Shakespeare'
             else "Don't know"
             end 

  * case statement use === for comparison, so it can be used for identify instances

    obj = SomeClass.new
    
    case obj
    when SomeClass
      puts 'it is RubySyntax'
    else 
      puts 'no no ...'         
    end

  * case statement to detect regular expression match

    case title
    when /War And .*/
      puts 'Maybe Tolstoy?'
    when /Romeo And .*/
      puts 'Maybe Shakespeare?'
    else
      puts 'Absolutely no idea...'
    end


- Staying Out of Trouble 23

  * in Ruby, only false and nil are treated as false
  * even empty space, the string 'false' and 0 are 'truthy'
  * even a variable is 'truthy', you cannot compare it to true
    do_something if flag == true
    vs. do_something if flag
  * on the other hand, if you are testing for nil or false, be explcit
    if something.nil?
      ...
    end

- In the Wild 25

  * to initialize something if it is nil, use ||=
    @first_name = '' unless @first_name
    is the same as
    @first_name ||= ''
    which is
    @first_name = @first_name || ''
  * ||= has the danger of overwrite the value if the value is false
    it is looking for nil, but accidentally triggered by false
  * Don’t try to use ||= to initialize things to booleans

-----------------------------------------------------------
Chapter 3: Take Advantage of Ruby’s Smart Collections 29
-----------------------------------------------------------

  * hashes and arrays
  * set is a collection of unordered values with no duplicates

- Literal Shortcuts 29

  * use %w{...} for arrays
    poem_words = [ 'twinkle', 'little', 'star', 'how', 'I', 'wonder' ]
    is the same as
    poem_words = %w{ twinkle little star how I wonder }
  * use hash rockets => for hash
    freq = { "I" => 1, "don't" => 1, "like" => 1, "spam" => 963 }
  * for most case, the key is symbol instead of string
    book_info = { :first_name => 'Russ', :last_name => 'Olsen' }
    or even simpler
    book_info = { first_name: 'Russ', last_name: 'Olsen' }

- Instant Arrays and Hashes from Method Calls 30

  * create/retrieve collections from method call

    def take_all_args ( *args )
      args
    end

    def take_at_least_two( first_arg, *middle_args, last_arg )
      [first_arg] + middle_args + [last_arg]
    end

  * splat: “splat names” , use *args instead of args
    the caller don't have to specify the array

    method_call 'one', 'two', 'three'

    instead of 

    method_call ['one','two','three']

  * splat can work the other way
    when calling a method (arg1, arg2, arg3) with args = ['one', 'two', 'three']

    method_call(*args)

  * for method taking a hash

    def load_font( specification_hash )
      # Load a font according to specification_hash[:name] etc.
    end

    you can call with hash

    load_font( { :name => 'times roman', :size => 12 })

    or, because the last arg is a hash

    load_font( :name => 'times roman', :size => 12 )

    even simpler (common in Rails)

    load_font :name => 'times roman', :size => 12 

- Running Through Your Collection 33

  * use each instead of for
  * for hash
    movie = { title: '2001', genre: 'sci fi', rating: 10 }
    movie.each { |entry| pp entry } #pp is pretty-print
    or
    movie.each { |name, value| puts "#{name} => #{value}"}
  * Array API has very extensive methods, such as
    - find_index
    def index_for( word )
      words.find_index { |this_word| word == this_word }
    end
    - map: transforming the contents of a collection
en mass
      lower_case_words = doc.words.map { |word| word.downcase }
    - inject: in addition to each element, you get the current result
      from this: 
      def average_word_length
        total = 0.0
        words.each { |word| total += word.size }
        total / word_count
      end
      to this: 
      def average_word_length
        total = words.inject(0.0){ |result, word| word.size + result}
        # 0.0 is the initial value of result
        total / word_count
      end

- Beware the Bang! 36

  * some array method change the current instance, while some methods return a new instance
  * methods with ! signals that it will change the current instance
    - reverse vs. reverse!
    - sort vs. sort!
  * in general, method names end with ! means 'dangerour or unexpected result'

- Rely on the Order of Your Hashes 38

  * Ruby arrays and hashes are both ordered.
  * adding an item to hash will add to the end of the array

- In the Wild 38

  * ruby try to use simple collections instead of a new class
  * call File.readlines(file_path) gets a simple array full of strings.
  * XmlSimple gem : use simple collection to represent Xml data
    require 'xmlsimple'
    data = XmlSimple.xml_in('dc.xml')

- Staying Out of Trouble 40

  * don't change the collection (delete or add elements) while traversing elements
  * this will instantly created 24,602 new elements of array, most of them set to nil
    array = []
    array[24601] = "Jean Valjean"
  * choose the right collection for the job
    require 'set'
    word_set = Set.new( words )
  
- Wrapping Up 42

-----------------------------------------------------------
Chapter 4: Take Advantage of Ruby’s Smart Strings 43
-----------------------------------------------------------

- Coming Up with a String 44

  * single quote : limited
  * double quote
    - can insert special characters such as \t \n
    - interpolation #{...}
  * %q{...} %q(...) or %q<...>
  * %Q .... will behave more like double quote
  * all literal strings can span multiple lines
    - to avoid being interpreted as new line use \
  * here document

- Another API to Master 47

  * String API methods
    - chomp: take out one newline charater from the end
    - chop : take out one character
    - upcase, downcase, swapcase
    - sub and gsub (global)
      'It is warm outside'.sub( 'warm', 'cold' )
    - split : turn string into word array
    - index
  * most methods return new string, but adding ! will alter the current string

- The String: A Place for Your Lines, Characters, and Bytes 49

  * each_char : get each char one at a time
  * each_byte : get each char as byte
  * each_line : get each line one at a time
  * since each can mean a lot of thing, String does not have 'each' method

- In the Wild 50

  * string manipulation is everywhere
    - html_escape in RSS library make a string suitable for HTML or XML
  * Rails use string processing to intelligently know when to infer CamelCase or snake_case
  * also Rails use gsub for pluraization of words

- Staying Out of Trouble 51

  * Ruby string is mutable, so if variable assigned, it still point to the same string
    - try to create a new string everytime (use upcase instead of upcase!)
  * take usage of string indexing
    first_name[first_name.size - 1]
    is the same as
    first_name[-1]
    "abcde"[3..4] # => return de

- Wrapping Up 52

-----------------------------------------------------------
Chapter 5: Find the Right String with Regular Expressions 53
-----------------------------------------------------------

  Ruby programmers do A LOT of regular expression

- Matching One Character at a Time 54

  * usually match character by character
  * . will match any single-character string including r and % and ~
  * \. will match .

- Sets, Ranges, and Alternatives 55

  * [0123456789] will match any single digit
  * [0123456789abcdef] will match any single hexadecimal deigit
  * use range
    [0-9a-f] ==> [0-9abcdef] ==> [0123456789abcdef]
    [0-9a-zA-Z_] ==> match any thing alphanumeric plus _
  * other special character
    - \d
    - \w
    - \s any white space space/tab/newline
  * alternative
    - A\.M\.|AM|P\.M\.|PM ==> will match AM/PM/A.M./P.M.

- The Regular Expression Star 57

  * * : zero or more

- Regular Expressions in Ruby 58

  * regular expression literal
    /\d\d:\d\d (AM|PM)/
  * to match
    /\d\d:\d\d (AM|PM)/ =~ '10:24 PM'
    or, '10:24 PM' =~ /\d\d:\d\d (AM|PM)/
    - will return 0, means it matches at the index of zero
    - if no match will return nil
  * to match case insensitively
    puts "It matches!" if /AM/i =~ 'am'
  * a lot of string methods accepts regularexpression as search string
    @content.gsub!( /\d\d:\d\d (AM|PM)/, '**:** **' )

- Beginnings and Endings 60

  * \A begining of text
  * \z end of text
  * ^ : the beginning of the string or the beginning of any line within the string.
  * $
  * to match across multiple like use /m
    /^Once upon a time.*happily ever after\.$/m

- In the Wild 62
  
  * Time class in time.rb
  * zone_offset use regular expression to figure out the timezone
    if /\A([+-])(\d\d):?(\d\d)\z/ =~ zone ... matches stuff like +05 or -05:00 as timezone

- Staying Out of Trouble 63

  * =~
  * return zero means it matches at the beginning of the string

- Wrapping Up 64

-----------------------------------------------------------
Chapter 6: Use Symbols to Stand for Something 65
-----------------------------------------------------------

- The Two Faces of Strings 65

  * Symbols are really just strings
  * a way to do magic string or enum
    book = Book.find(:all)

- Not Quite a String 66

  * string has two meanings:
    - the characters inside
    - the meaning of this specific arrangement of characters
      book = Book.find(:all)
      the :all here give us a special meaning of 'finding all books'
  * if you are using some characters to stand for something in your code, you probably are not very interested in messing with the actual character

- Optimized to Stand for Something 67

  * symbol is optimized to stand for something
  * there can only ever be one instance of any given symbol
    very good for comparison
    a = :all
    b = a
    c = :all    
    # True! All true!
    a == c
    a === c
    a.eql?(c)
    a.equal?(c)
  * symbols are immutable
  * these characters make symbols ideal for hash keys

- In the Wild 69

  * to_s method turn a symbol to string
  * to_sym turns a string to a symbol
  * all objects has a public_methods method
    - returns a list of strings in > Ruby 2
    - returns a list of symbols in < Ruby 2

- Staying Out of Trouble 70

  * Use symbols when you simply want an intelligible thing that stands for something in your code
  * sometimes people will forget to use symbols as hash keys --> always use symbos
    ruby has a HashWithIndifferentAccess class try to mitigate the confusion

- Wrapping Up 71

  * symbols and strings: two siblings with different talents

-----------------------------------------------------------
Chapter 7: Treat Everything Like an Object—Because Everything Is 73
-----------------------------------------------------------

- A Quick Review of Classes, Instances, and Methods 74

  * Class has two purposes
    - a place to define methods
    - a factory to create new instances
  * self : default object for instances
  * don't use self.method if method will do
  * use < for inheritance
    class RomanceNovel < Document
      # Lot's of steamy stuff omitted...
    end
  * all classes are subclasses of Object class

- Objects All the Way Down 76

  * -3.abs
  * "abc".upcase
  * :abc.length
  * /abc/.class --> Regexp
  * true.class --> TrueClass
  * false.class --> FalseClass
  * true.class.class --> Class (eventually class)

- The Importance of Being an Object 77

  * to override a method, just redefine in the subclass
  * eval is defined in Object
    - eval takes a string and execute it 
    - very powerful
  * other methods in Object
    - instance_of?
    - public_methods
    - instance_variables

- Public, Private, and Protected 79

  * by default: all methods are public
    - called everywhere in the program
  * private
    - by putting private in class
    - or by putting private at the bottom of class
    - cannot call a private method with an explicit object reference
    - in Ruby, private methods are callable from subclasses
  * protect 
    Any instance of a class can call a protected method on any other instance of the class.
  * in real Ruby code, visibility is not used quite often
  * even visibility is limited, one can still use 'send' method in Object to invoke private/proted methods
    n = doc.send( :word_count )

- In the Wild 81

  * a lot of ruby code are method calls, private/protected are method call
  * require is a method call that takes the name of file and execute the content of the file
  * other method calls
    - attr_accessor
    - attr_reader
    - attr_writer

- Staying Out of Trouble 82

  * Object class defines 50+ methods
    - these methods can be called everywhere without instance
    - try not to define your methods with the same name, or there will bename collision, such as send/to_s
  * be careful when overriding methods of Object class
  * in Ruby everything is an object (Object class)
    - you don't have to do null handling or special case handling based on types

  a great way to avoid broken code is to have less of it  

- Wrapping Up 84

-----------------------------------------------------------
Chapter 8: Embrace Dynamic Typing 85
-----------------------------------------------------------

  How can you possibly write reliable programs without some kind
of static type checking? And why?

- Shorter Programs, But Not the Way You Think 85

  * allow for more compact code 
    - don't have to specify type
    - don't have to declare variables
    - don't need interface/abstrac_class
    - don't need the casts and d erived types
  * you need to be aware of the possibility and write your code the dynamic typing way
  * duck typing: only care about what an object can do

- Extreme Decoupling 89

  * example: you want to change the type of class's data member
  * you don't have to do anything as long as you don't do anything special about the data members
  * don't do type checking
    - it defeat the purpose of dynamic typing
    - it bloats code
  * “The method is either there or it is not,”

- Required Ceremony Versus Programmer-Driven Clarity 92

  * declaring type sometimes become ceremonial
  * use clarity instead of type declaration to explain

- Staying Out of Trouble 93

  * problems of dynamic typing
    - missing method definition (relax, it is not that bad)
  * try to write your code clear and concise
  * write lots of tests

In the Wild 94

  * “if the method is there, it is the right object”
    
    open_file = File.open( '/etc/passwd' )

    or
    
    require 'stringio'
    open_string = StringIO.new( "So say we all!\nSo say we all!\n" )

    it is coincident that they share some same methods

    - readchar
    - readline
    - seek(n)
  * where subclassing is driven more from practical considerations than considering of type analysis
  * “don’t artificially couple your classes together”
    - in Set class when initialize with Array
    - some code unnecessarily check type of array is Enumerable
    - in face, all you care is if you can call 'each' on it

- Wrapping Up 96

  * First, don’t create more infrastructure than you really need. 
  * Keep in mind that Ruby classes don’t need to be related by inheritance to share a common interface; they only need to support the same methods.
  * Don’t obscure your code with pointless checks to see whether this really is an instance of that. 
  * Do take advantage of the terseness provided by dynamic typing to write code that simply gets the job done with as little fuss as possible—but 
  * Keep in mind that someone (possibly you!) will need to read and understand the code in the future.
  * WRITE A LOT OF TESTS

-----------------------------------------------------------
Chapter 9: Write Specs! 97
-----------------------------------------------------------

  * A key part of the Ruby style of programming is that no class, and certainly no program, is ever done if it lacks automated tests.
  * Two different test framework
    Test::Unit
    RSpec

- Test::Unit: When Your Documents Just Have to Work 98

  * part of xUnit suite
  * require 'test/unit'
  * just run the file as regular ruby file
  * assert_equal and assert
  * use setup and teardown

- A Plethora of Assertions 101

  * assert_match /times.*/, 'times new roman'
  * assert_instance_of String, 'hello'
  * assert that the code raise error
    assert_raise ZeroDivisionError do
      x = 1/0
    end
  * assert that the code does NOT raise error
    assert_nothing_thrown do
      x = 1/2
    end

- Don’t Test It, Spec It! 101

  * test vs. spec
  * spec is about expectation and behavior, not data
  * a spec is something like this: 
    About the Document class: When you have a document instance, it should 
    hang onto the text that you give it. It should also return an array 
    containing each word in the document when you call the words method. 
    And it should return the number of words in the document when you call the word_count method.
  * expect
    expect(...).to eq(...) # test equality
    expect(...).to be(...) # test equality
    expect(...) # test true

- A Tidy Spec Is a Readable Spec 104

  * rspec 
    - it 'behavior' do : describe a behavior
    - before :each do ... : setup 
    - after :each
    - before :all
    - after :all

- Easy Stubs 105

  * how to isolate the class in test without testing supporting classes?
    - stub (a class that has the same interface as the supporting class)
      aka: stand-in class
    - mock
  * rspec make creating stub very easy, you just create a dynamic object with the method implementation (fake ones)
    - stub (create a new object)
      stub_printer = stub :available? => true, :render => nil
    - stub! (modify an existing object/class)
      apparently_long_string = 'actually short'
      apparently_long_string.stub!( :length ).and_return( 1000000 )

- . . . And Easy Mocks 107

  * mock: we need to verify the behavior of the class-in-test
  * A mock is a stub with an attitude (expectations).
    - knowing what canned responses to return
    - knows which methods should be called and with what arguments
    - and how many times
  * example:
    mock_printer = mock('Printer')
    mock_printer.should_receive(:available?).and_return(true)
    mock_printer.should_receive(:render).exactly(3).times
  * http://rspec.info/

- In the Wild 108

  * if using Test::Unit, there are other useful tools
    - shoulda (expectation syntax)
    - mocking (mock)
  * check out RubySpec
    - a spec for Ruby language itself

- Staying Out of Trouble 110

  * keep tests fast
  * tests should communicate clearly where it got failure/errors
  * tests should be silent if no errors
  * tests should be independent of each other
  * fail tests first before you implement
  * some simple tests are better than no tests

- Wrapping Up 113

  * write tests/specs

===========================================================
PART II: Classes, Modules, and Blocks 115
===========================================================

-----------------------------------------------------------
Chapter 10: Construct Your Classes from Short, Focused Methods 117
-----------------------------------------------------------

- Compressing Specifications 117

  * how to create good methods?
  * ruby prefers short and focused methods
  * short methods works great with ruby
  * short methods made code more testable

- Composing Methods for Humans 121

  * example: implementing a text compression class
    - take a string and output two arrays
    - one array is all the unique words
    - second array is the representation of the string using the first array's indexes
  * taking two refactorings:
    - goal is to make short and focused methods

      def unique_index_of( word )
        @unique.index(word)
      end
      def add_unique_word( word )
        @unique << word
        unique.size - 1
      end

    - use ruby to make code clear

      i = unique_index_of( word )
      if i
        @index << i
      else
        @index << add_unique_word( word )
      end

      to use || instead of if... else

      i = unique_index_of( word ) || add_unique_word( word )
      @index << i

- Composing Methods for Human 121

  * The composed method technique advocates dividing your class up into methods that have three characteristics.
    - single responsibility for all code within
    - single conceptual level for all code within
    - clear name 
  * smaller methods are easy-to-comprehend and will help you get the details right.

- Composing Ruby Methods 122

  * short method are good for ruby because it is really easy to create/maintain methods
  * also short methods are easy to test

- One Way Out? 123

  * multiple return places make the code hard to comprehend
  * shorter methods make the code clearn and don't have to worry about multiple returns

- Staying Out of Trouble 126

  * two things to remember about methods
    - short
    - coherent
  * sometimes, try to create short methods only add clutter

- In the Wild 127

  * example: ActiveRecord::Base
    - short with average 9 lines of code
    - good and descriptive names

- Wrapping Up 128

-----------------------------------------------------------
Chapter 11: Define Operators Respectfully 129
-----------------------------------------------------------

- Defining Operators in Ruby 129

  * it is powerful to be able to redefine standard operations
  * Ruby supports
    * plus and risks

  * Ruby's philosophy is to empower programmers, don't keep secret
  * you can define your own Float and have all the standard numeric operators with it
  * Ruby translates operators to corresponding method calls
    result = first + second * (third - fourth)
    ==>
    result = first.+(second.*(third.-(fourth)))

    class Document
      # Most of the class omitted...
      def +(other)
        Document.new( title, author, "#{content} #{other.content}" )
      end
    end

- A Sampling of Operators 131

  * popular operators overloads
    + - / *
    %(mode) & | ^ (exclusive or)
    << (Ruby use this to mean - add another)
    +@ (+ as unary) -@ (- as unary)
  * array operator
    [](index) ==> for retrieving an element obj[3]
    []=(index, obj) ==> for assign an element at location
    - if array operators are defined, better define 'size' so users know the index range

- Operating Across Classes 134

  * if define an operator across classes of objects, it is better to define the same operator for all classes

- Staying Out of Trouble 135

  * when to use operator overloading
    - if your class is a natural candidate for numeric operations
    - if your class is a collection
      - define <<
      - if index is supported [] and []=
  * operators should not modify operands

- In the Wild 137

  * Time can do operations, but not commutative
    Time.now
    one_minute_from_now = now + 60 
  * string class overload %
    "The value of n is %d" % 42
  * RSpec should
    x.should == 42

- Wrapping Up 139

  * equality (== and ===) is totally separate subject

-----------------------------------------------------------
Chapter 12: Create Classes That Understand Equality 141
-----------------------------------------------------------

  object equality is a tough question
  important for creating well-behaved objects

- An Identifier for Your Documents 141

  * create a DocumentIdentifier class to identify Document objects with @name and @folder
  * question: how to compare two DocumentIdentifier objects

- An Embarrassment of Equality 142

  * in Ruby there are four methods for equality
    - eql?
    - equal?
      * for object identify
      * no need to override, ever
    - ==
    - ===

- Double Equals for Everyday Use 143

  * == default behavior is equal?
  * can be overriden

  def ==(other)
    return true if other.equal?(self)
    return false unless other.instance_of?(self.class)
    folder == other.folder && name == other.name
  end 

  * nice, no need to check nil

- Broadening the Appeal of the == Method 145

  * if want to also allow subtypes
    change instance_of? to kind_of?
  * if want to totally don't care about type heirarchy
    use respond_to?

    def ==(other)
      return false unless other.respond_to?(:folder)
      return false unless other.respond_to?(:name)
      folder == other.folder && name == other.name
    end

- Well-Behaved Equality 146

  * be aware of the principla of symmetry
    - if a == b, this should be true too: b == a
  * transive principle
    - if a == b, and b == c
      a == c should be true
  * rethink about overriding ==
    - do we really need to allow == to do that many things?
    - why not make it less smart

- Triple Equals for Case Statements 149

  * === is used when compare in case statement
  * this is to allow this code: 

    location = 'area 51'
    case location
    when /area.*/
      # ...
    when /roswell.*/
      # ...
    else
      # ...
    end

  * the Regexp class implements === that does pattern matching
  * most of the time === is just the same as ==
    ==> better to leave this alone

- Hash Tables and the eql? Method 150

  * implicity called in Hash table situation
  * only needed when your object will be used as Hash key
  * but still not easy, need to have the same hash key

- Building a Well-Behaved Hash Key 152

  * The Hash class calls the hash method (another one of those methods that you inherit from Object) to get the hash code from its keys. The Hash class uses the eql? method to decide if two keys are in fact the same key.
  * override both hash value and eq?

    def hash
      folder.hash ^ name.hash
    end

    def eql?(other)
      return false unless other.instance_of?(self.class)
      folder == other.folder && name == other.name
    end

- Staying Out of Trouble 153

  * don't try to be fancy
    Many objects will never find themselves in the middle of an equality expression or be called upon to be a hash key.
  * if your class is just a wrapper, borrow code

    class DisArray
      attr_reader :my_array
      
      def initialize
        @my_array = []
      end
      def ==(other)
        return false unless other.kind_of?(DisArray)
        @my_array == other.my_array
      end
      def eql?(other)
        return false unless other.kind_of?(DisArray)
        @my_array.eql?( other.my_array )
      end
      def hash
        @my_array.hash
      end

      # Rest of the class omitted...
    end

  * do the simplest thing that might work
    don't try to do cross class equality if you can avoid it

- In the Wild 154

  * in Ruby, integer (FixNum) and Float class can use ==
  * if you define <=>, with Comparable module included
    ==> ruby will implement ==, < <=, ... etc for you

    class RomanNumerals
      include Comparable
  
      # Actual guts of the class omitted...
  
      def <=>(other)
        # Return -1, 0, or 1...
      end
    end

  * <=> should return -1 if a is less than b, 0 if they are equal, and 1 if a is greater than
  * ruby classes (subclass of Class), implement === with kind_of? to allow: 

    the_object = 3.14159
    case the_object
    when String
      puts "it's a string"
    when Float
      puts "It's a float"
    when Fixnum
      puts "It's a fixnum"
    else
      puts "Dunno!"
    end
  * because of the above, you can even write
    Float === 1.0

- Wrapping Up 156

  * getting object equality right can be trying, it is certainly doabl
  * understand the equality model well

-----------------------------------------------------------
Chapter 13: Get the Behavior You Need with Singleton and
Class Methods 157
-----------------------------------------------------------

  * class hierarchy/model is the essential part of OO
  * what do you do when the class/instance approximation breaks down?
    - what to do when the instance does not want to follow the spec of class?
    - singleton method is Ruby's solution
    - class method is just another name of singleton method

- A Stubby Puzzle 158

  * recall Rspec use stub method to create stub objects

  stub_printer = stub :available? => true, :render => nil
  stub_font = stub :size => 14, :name => 'Courier'

  * all stub objects are of class Mock
  * all the stubbed methods (:available?, :render, ... etc) are singleton methods
  * singleton methods
    - methods that are designed for only one object instance
    - how to define?
      (def instance.method_name)

      hand_built_stub_printer = Object.new
      def hand_built_stub_printer.available?
        true
      end
      def hand_built_stub_printer.render( content )
        nil
      end
  * Singleton methods override any regular, class-defined methods. 
  * alternative way to create singleton methods:

    class << hand_built_stub_printer
      def available? # A singleton method
        true
      end
      def render # Another one
        nil
      end
    end

- A Hidden, but Real Class 160

  * how is 'singleton methods' implemented?
  * every Ruby object carries around an additional, somewhat shadowy class of its own
  * called 'singleton class' 
    (or metaclass or eigenclass)
  * how to get hold of 'singleton class'

    singleton_class = class << hand_built_stub_printer
      self
    end

    - 'class << hand_built_stub_printer' changed the context, so 'self' is the singleton class
    - by returning it, the singleton_class vairiable will pont to it

Class Methods: Singletons in Plain Sight 162

  * class methods: methods that are defined in the class
  * ways to define class methods

    def Document.explain
      puts "self is #{self}"
      puts "and its class is #{self.class}"
    end

    class Document
      def self.create_test_document( length )
        Document.new( 'test', 'test', 'test ' * length )
      end
      # ...
    end

    class Document
      class << self
        def find_by_name( name )
          Class Methods: Singletons in Plain Sight 163
          # Find a document by name...
        end
      end
      # ...
    end

  * in essence, class methods are singleton methods
  * just whether the class is the instance's 'singleton class' or the regular 'class' (which is an instance of the class Class)

In the Wild 164

  * in ActiveRecord, table_name is a class method
    
    class Author < ActiveRecord::Base
    end

    my_table_name = Author.table_name

  * use class methods for Factory methods to create new instances of the class

    require 'date'
    xmas = Date.civil( 2010, 12, 25 )
    xmas = Date.commercial( 2010, 51, 6 )

  * obj.singleton_methods will give you a list of singleton methods

Staying Out of Trouble 165

  * be aware of different scope
  * class methods are not visible to instances
  * or, use obj.class.class_method to call it
  * class methods can also be inherited
    (a topic in metaprogramming)

    class Parent
      def self.who_am_i
        puts "self is #{self}"
      end
    end

    class Child < Parent
    end  

    Parent.who_am_i ==> self is Parent
    Child.who_am_i ==> self is Child

Wrapping Up 167

  * signleton method, class method
  * singleton class

-----------------------------------------------------------
Chapter 14: Use Class Instance Variables 169
-----------------------------------------------------------

  * programs deal with data
  * where to store class-level data
    - class variable @@
      (have some undesireable behaviors)
    - class instance variable
      (more practical for use)

- A Quick Review of Class Variables 169

  * using class variable @@
    - not visible outside the class
    - visiable to instances of the class
    - example

      class Document
        @@default_paper_size = :a4

        def self.default_paper_size
          @@default_paper_size
        end

        def self.default_paper_size=(new_size)
          @@default_paper_size = new_size
        end

          attr_accessor :title, :author, :content
          attr_accessor :paper_size
        
        def initialize(title, author, content)
          @title = title
          @author = author
          @content = content
          @paper_size = @@default_paper_size
        end

        # Rest of the class omitted...
      end 

- Wandering Variables 171

  * problem with class variable
    => when resolving the varaible, Ruby travels class hierarchy to know which class
  * for assigning @@default_paper_size = :a4
    - first look at current class
    - if not, look up the hierarchy
    - if run out, create the @@default_paper_size in current class
  * for getter
    - first look at current class
    - if not, look up the hierarchy
    - if run out, throw NameError exception
  * Document, Resume, Presentation class hierarchy
    - end result -> based on the order of require, the class variable will be set/overwrite
  * this is very similar to the 'global variable' problem. 
    Just in this case, the variable is global within the inheritance tree
     
- Getting Control of the Data in Your Class 174

  * instead of using @@, why not use @ at the class instance

    class Document
      @default_font = :times
      
      def self.default_font=(font)
        @default_font = font
      end
  
      def self.default_font
        @default_font
      end
  
      def initialize(title, author)
        @title = title
        @author = author
        @font = Document.default_font
      end      
    end

- Class Instance Variables and Subclasses 175

  * class instance variables do just fine with subclasses
  * child classes can have the same class instance variable

    class Presentation < Document
      @default_font = :nimbus
      class << self
        attr_accessor :default_font
      end
      def initialize(title, author)
        @title = title
        @author = author
        @font = Presentation.default_font
      end
      # most of the class omitted...
    end  

- Adding Some Convenience to Your Class Instance Variables 176

  * to avoid defining getters and setters, use the 'class << self'

    class Document
      # @variables defined here is associated with the class, not instance
      @default_font = :times
    
      class << self
        attr_accessor :default_font
      end
    
      # Rest of the class omitted...
    end

- In the Wild 177

  * Rails use class instance variables to regiter callbacks
    - example: ActiveRecord
    - the call after_save actually keeps the callback function in a class instance variable (defined in ActiveRecord::Base) call @after_save_callbacks

    class Person < ActiveRecord::Base
      after_save :handle_after_save
      def handle_after_save
      # Do something after the record is saved...
      end
    end

  * class variables @@ are still useful 
    - example: URI parsing
    - URI class hold a @@schemes variable
    - every kind of schema will need to add itself to the variable

      class HTTP
        # Lots of code omitted...
      end
      @@schemes['HTTP'] = HTTP

    - @@schema is not only a class variable, it is a 'module variable'

      module URI
        # ...
        @@schemes = {}
      end
      module URI
        class HTTP
          # Lots of code omitted...
        end
        @@schemes['HTTP'] = HTTP
      end

- Staying Out of Trouble 179

  * if class variables are to be used, follow what @@schems does
  * declare the @@schemes early in the module before any other code can access it

- Wrapping Up 179

  * class variables can be confusing
  * class instance variables are there to fill in the role

-----------------------------------------------------------
Chapter 15: Use Modules as Name Spaces 181
-----------------------------------------------------------

  * for larger projects, we need a way to organize things
  * modules is a way to organize the classes and constants (and modules) into a friendly hierarchy

- A Place for Your Stuff, with a Name 181

  * multi-hats of classes
    - factory
    - container
    - methods and constants
    - play in class hierarchy (be super)
  * module is the container part of class without factory
    - cannot be instantiate
    - can hold
      - methods
      - constants
      - classes
      - other modules

      module Rendering
        class Font
          attr_accessor :name, :weight, :size
          def initialize( name, weight=:normal, size=10 )
            @name = name
            @weight = weight
            @size = size
          end
          # Rest of the class omitted...
        end
        class PaperSize
          attr_accessor :name, :width, :height
          def initialize( name='US Let', width=8.5, height=11.0 )
            @name = name
            @width = width
            @height = height
          end
          # Rest of the class omitted...
        end

        DEFAULT_FONT = Font.new( 'default' )
        DEFAULT_PAPER_SIZE = PaperSize.new
      end

  * to access the class inside module 
    - Rendering::Font
    - Rendering::DEFAULT_FONT
  * to avoid typing module names use:
    include Rendering

- A Home for Those Utility Methods 184

  * use Module to hold utility methods
    - defined as self. (module-level methods)
    - calling: WordProcessor.inches_to_points( 1.0 )
    - or (less used) WordProcessor::inches_to_points( 1.0 )

    module WordProcessor
      def self.points_to_inches( points )
        points / 72.0
      end
      def self.inches_to_points( inches )
        inches * 72.0
      end
      # Rest of the module omitted
    end

- Building Modules a Little at a Time 185

  * Ruby's code is always open to extension (modifications)
  * Modules can be defined in two separate files and pull them in together by two requires

- Treat Modules Like the Objects That They Are 186

  * everything is object, including module

    the_module = Rendering
    times_new_roman_font = the_module::Font.new('times-new-roman' )

  * we can use this to swap modules, as long as the two modules support the same functionalities(methods/constants .... (interface))

- Staying Out of Trouble 189

  * when to use namespace modules?
    - when you create a lot of related classes
  * when defining utility methods in modules, make sure use 'self.'
    - if not, the method cannot be used (unless being mixed in to another class)
  * don't nest modules too deep

- In the Wild 190

  * examples:
    - DataMapper
    - YAML

- Wrapping Up 191
  
  * use module to divide up the code
  * module can be used as object too
  * another use of module: as mix-ins

-----------------------------------------------------------
Chapter 16: Use Modules as Mixins 193
-----------------------------------------------------------

  class can be 'super' (play in hierarchy of classes)
  modules can be used to 'inject' (mix-in) into class hierarchy
  mix-in allow you to 'share' common code in unrelated classes

- Better Books with Modules 193
  
  * example: we have two separate class heirarchy
  * you have a piece of code that you want to share among them
  * you can create a super-class and have the two classes both inherit it
  * or, cleaner, use 'mix-in'

- Mixin Modules to the Rescue 195

  * by including a module in a class you have mixed it in to the class. 
  * the module itself, WritingQuality in this case, is a mixin mod- ule. 
  * it is possible, and common, to include multiple modules in a class

- Extending a Module 197

  * instead of mix-in methods to become instance methods
  * use extend to mix-in the methods as singleton class methods

    class Document
      extend Finders
      # Most of the class omitted...
    end

- Staying Out of Trouble 198

  * implementation
    When you mix a module into a class, Ruby rewires the class hierarchy a bit, inserting the module as a sort of pseudo superclass of the class.
  * No matter how many modules a class includes, instances of the class will still claim to be, well, instances of the class.
  * but, you can use kind_of? to find out if an object is from a class that includes certain module
  * or, use ClassName.ancestors to get a list of superclasses and moduels
  * the class can override the methods in the included module
  (since when you include a module, Ruby create an immediate super class on top of the class)
  * if you include multiple modules, each include will bump the other modules up one level
  * when writing modules, think through the interface itneraction between the module and the class - use comment to warn the including class author

- In the Wild 202

  * module can contains all kind of things
    - methods
    - constants
    - ... etc
  * DataMapper is a good example of using module instead of super class
  * helpers
    - in Rails' view helper

    module ActionView
      # Huge amounts of code and helpful documentation omitted...
      module Helpers
        module FormHelper
          def label(object_name, method, text = nil, options = {})
             # ...
          end
          def radio_button(object_name, method, tag_value,options={})
            # ...
          end 
        end
      end
    end

  * constants
    - sqlite3
      
      module ErrorCode
        OK         =  0   # Successful result
        ERROR      =  1   # SQL error or missing database
        INTERNAL   =  2   # An internal logic error in SQLite
        PERM       =  3   # Access permission denied
        ABORT      =  4   # Callback routine requested an abort
        BUSY       =  5   # The database file is locked
        LOCKED     =  6   # A table in the database is locked
        # Seemingly endless list of remaining error codes omitted...
      end

    - by including this module, you can access OK/ERROR/ ... directly  

- Wrapping Up 205

  * use mix-in
  * mix-in will create phantom super class
  * be aware of the interface between module and the including classes

-----------------------------------------------------------
Chapter 17: Use Blocks to Iterate 207
-----------------------------------------------------------

- A Quick Review of Code Blocks 207

  * calling method with code block as argument

    do_something do
      puts "Hello from inside the block"
    end

    do_something { puts "Hello from inside the block" }

  * handling the code block argument

    def do_something
      yield if block_given?
    end  

  * with arguments

    def do_something_with_arg (a, b)
      yield a, b if block_given?
    end

    # calling

    do_something_with_arg do |a, b|
      pp a
      pp b
      puts "Hello from inside the block "
    end

  * code block does return a value

- One Word after Another 209

  * if really wanted, you can define your own eachXX method

    class Document
      # Stuff omitted...
      def each_word
        word_array = words
        index = 0
        while index < words.size
          yield( word_array[index] )
          index += 1
          end
      end
    end

  * but since words is already a collection, why not just use it?

    def each_word
      words.each { |word| yield( word ) }
    end

- As Many Iterators as You Like 210

  * can have multiple iterators
  * you can iterate through as much as possible
  * can give any names

- Iterating over the Ethereal 211

  * you can write iterators that run through collections that don’t actually exist, at least not all at the same time.

    12.times { |x| puts "The number is #{x}" }

  * just need to return something one at a time

    def each_word_pair (words)
      word_array = words
      index = 0
      while index < (word_array.size-1)
        yield word_array[index], word_array[index+1]
        index += 1
      end
    end

    words = ['harry', 'chou', 'rocks', 'yeah']
    each_word_pair words do |first, second|
      puts "#{first}, #{second}"
    end    

- Enumerable: Your Iterator on Steroids 213

  * you can use Enumerable module to enhance your collection class
    - just need to define the each method
  * Enumerable module gives you some methods to use
    - include?
    - to_a (return an array)
    - find
    - find_all
    - each_cons(n)
      repeatedly call the block, each time passing in an array of consecutive elements from the collection
    - each_splice
    - count
    - if <=> defined, can use sort
  * Enumertor
    you can also use Enumerator class to create a enumerable based on any arbitrary eachXX method

    enum = Enumerator.new( doc, :each_character )

- Staying Out of Trouble 215
  
  * block is external to the classes that use it
    - be careful how the block works
    - block can raise exception too
      * use exception handling

        def each_name
          # Get some expensive resource
          name_server = open_name_server 
          
          begin
            while name_server.has_more?
            yield name_server.read_name
            end
          ensure
            # Close the expensive resource
            name_server.close 
          end
        end

    - block can also run slow or never stop
      * use break or return
      * break: 
        break will trigger a return out of the method that called the block.
      * return:
        the method that defined (not called) the block to return
      * both break and return will trigger 'ensure'

- In the Wild 217

  * Dir class use block to iterate over directory

    etc_dir = Dir.new("/etc")
    etc_dir.each {|entry| puts entry}

  * Resolv (find all the IP addrs using DNS)

    require 'resolv'
    Resolv.each_address( "www.google.com" ) {|x| puts x}

  * ObjectSpace.each_object

    ObjectSpace.each_object(String) { |the_string| puts the_string }

  * find all Primes

    require 'mathn'
    # Warning: According to Euclid, this never stops...
    Prime.each {|x| puts "The next prime is #{x}" }

- Wrapping Up 218

  * As long as you can come up with one element after another, you can build an iterator.

-----------------------------------------------------------
Chapter 18: Execute Around with a Block 219
-----------------------------------------------------------

  * use code block to deliver code to other places
  * how to provide data arguments and get return value
  * why method names are important

- Add a Little Logging 219

  * example: adding logging to your code
    - you don't want the logging to be everywhere
    - you don't want to disturb the general flow
    - you can use code block: 

      def do_something
        with_logging('load') { @doc = Document.load( 'resume.txt' ) }
        # Do something with the document...
        with_logging('save') { @doc.save } 
      end

      def with_logging(description)
        begin
          @logger.debug( "Starting #{description}" )
          yield
          @logger.debug( "Completed #{description}" )
        rescue
          @logger.error( "#{description} failed!!")
          raise
        end 
      end

    - this abstract out the begin/rescue/end block and also add logging logic to a central place
    - this also clearly communicate the code

- When It Absolutely Must Happen 224

  * this technique is called 'execution around'
    “bury the details in a method that takes a block” 
  * execute around means you take a block of code and you want to execute something before and/or after executing the code, or even handle exceptions 

- Setting Up Objects with an Initialization Block 225

  * sometimes when designing a class, you want your user to be able to add initialization logic

  def initialize(title, author, content = '')
    @title = title
    @author = author
    @content = content
    yield( self ) if block_given?
  end

- Dragging Your Scope along with the Block 225

  * a common mistake, you unnecessarily pass more data than needed
    - the code block has a closure
    - the variables are dragged along with the code block
  * the time you want to pass in argument to the method is for the containing method to use, not the code block

- Carrying the Answers Back 227

  * sometimes you want to capture the returned value of code block
  * and do something with it

- Staying Out of Trouble 228

  - for 'execute around' code block, the exception handling is important, because you want to ensure something code will happen before/after execution
  - keep the name reasonable for the caller to communicate the code's intent
  
- In the Wild 229

  * 'execute around' is commonly used for db or file object's open/connect methods

  File.open('/etc/passwd') do |f|
    # File open here!
    # Begin cracking the passwords on Russ' computer...
  end  

  * 'execute around' is also useful in initializing objects
    - exmaple: Gem::Specification

      SPEC = Gem::Specification.new do |s|
        #### Basic information.
        s.name = 'rake'
        s.version = $package_version
        s.summary = "Ruby based make-like utility."
        s.description = <<-EOF
          Rake is a Make-like program implemented in Ruby. Tasks
          and dependencies are specified in standard Ruby syntax.
        EOF
        # Lots and lots omitted!
      end
  * ActiveRecord's say_with_time method

    class Migration
      # Most of the class omitted...
      def say(message, subitem=false)
        write "#{subitem ? " ->" : "--"} #{message}"
      end
      def say_with_time(message)
        say(message)
        result = nil
        time = Benchmark.measure { result = yield }
        say "%.4fs" % time.real, :subitem
        say("#{result} rows", :subitem) if result.is_a?(Integer)
        result
      end
    end

  * ActiveRecord has a silence method too

- Wrapping Up

  * 'execute around' technique
  * useful when you have code that frequently needs to come before or after some other code, or both. 
  * build a method that takes a block; inside of that method you execute whatever code needs executing before and after you call the block. 

-----------------------------------------------------------
Chapter 19: Save Blocks to Execute Later 233
-----------------------------------------------------------

  * using blocks as a device for delivering your code where it is needed and execute when it is needed

- Explicit Blocks 233

  * our previous code use implicit block mechanism
  * sometimes, it is better the block is explicit
    - arg: &that_block
    - calling: that_block.call
    - if not passed in: that_block will be Nil
    - to check: that_block.call if that_block
  * explicit code block is preferred
  * explicit code block allow you to hold on to the code block to be executed later

- The Call Back Problem 234

  * Listener pattern
    - create specific listeners that can handle some events
    - the main class has the listeners registered (set)
    - when the event is triggered, the listeners get called
    - advantages:
      * separate listener allow simple purpose code
      * allow swap out the listener
    - disadvantages:
      * many classes to handle/maintain

- Banking Blocks 236

  * using code block: 

    class Document
      # Most of the class omitted...
      def on_save( &block )
        @save_listener = block
      end
      def on_load( &block )
        @load_listener = block
      end
      def load( path )
        #@content = File.read( path )
        @load_listener.call( self, path ) if @load_listener
      end
      def save( path )
        #File.open( path, 'w' ) { |f| f.print( @contents ) }
        @save_listener.call( self, path ) if @save_listener
      end
    end

  * calling code blocks

    doc = Document.new
    doc.on_load do |doc, path| 
      puts "loaded ...." << path
    end
    doc.on_save do |doc|
      puts "saved ...."
    end

    doc.save('test.txt')
    doc.load('test.txt')
    doc.save('test.txt')

  * the code is now shorter/concise and clean

- Saving Code Blocks for Lazy Initialization 237

  * lazy loading: avoid loading certain part of an object until it is accessed

    class ArchivalDocument
      attr_reader :title, :author

      def initialize(title, author, path)
        @title = title
        @author = author
        @path = path
      end

      def content
        @content ||= File.read( @path )
      end
    end

  * lazy_loading using block

    class BlockBasedArchivalDocument
      attr_reader :title, :author
      def initialize(title, author, &block)
        @title = title
        @author = author
        @initializer_block = block
      end
      def content
        if @initializer_block
          @content = @initializer_block.call
          @initializer_block = nil
        end
        @content
      end
    end

    file_doc = BlockBasedArchivalDocument.new( 'file', 'russ' ) do
      File.read( 'some_text.txt' )
    end  

    google_doc = BlockBasedArchivalDocument.new('http', 'russ') do
      Net::HTTP.get_response('www.google.com', '/index.html').body
    end      

- Instant Block Objects 239

  * to produce a code block object
    - an instance of "Proc" class
    - without using a method to hold it
    - use lambda (a method) to generate it

  * example: extend the lazy document with default initializer block 

    class Document
      DEFAULT_LOAD_LISTENER = lambda do |doc, path|
        puts "Loaded: #{path}"
      end
      DEFAULT_SAVE_LISTENER = lambda do |doc, path|
        puts "Saved: #{path}"
      end
      
      attr_accessor :title, :author, :content
      def initialize( title, author, content='' )
        @title = title
        @author = author
        @content = content
        @save_listener = DEFAULT_SAVE_LISTENER
        @load_listener = DEFAULT_LOAD_LISTENER
      end
      # Rest of the class omitted...
    end  

- Staying Out of Trouble 240

  * use 'Proc.new' vs. use lambda
    - Proc.new return instance is more forgiving in the number of args passed into 'call', created with 'lambda', the call will be more strict in receiving args
    - different behavior in return/break/next
      * Objects from Proc.new feature all of the interesting return, break, and next behavior. For example, if a Proc.new block executes an explicit return, Ruby will try to return not just from the block but from the method that created the block. This behavior is great for iterators, but it can be a disaster for applications that hang onto code blocks long after the method that created them has returned. 
      * In contrast, the Proc object returned from lambda acts more like a portable method—a return from a lambda wrapped block will simply return from the block and no further.
  * so, when to use 'Proc.new' when to use 'lambda'
    - if you want the method to behave like regualr method with return/next/break, use 'Proc.new'
    - else, use 'lambda'
  * be aware of the behavior of 'closure'
    - you many have some big/unwanted variable memories still dragging along with the closure

  * Ruby also supports a third way to create Proc instances, the 'proc' method. 
    - in 1.8, proc was synonymous with lambda. In 1.9 it is more like Proc.new. 

- In the Wild 243

  * RSpec use the it '...' do struct to execute tests
  * in Rails, controller use code block to setup filters
  * in ActiveRecord
  * all of them says ... hey here is a block of code ... execute it when the timing is right

  * Rake and Capistrano

- Wrapping Up 244

  * code block as a long-lived container of code
  * explicit block parameter
  * lambda

===========================================================
PART III: Metaprogramming 247
===========================================================

  * MetaProgramming in Ruby
    - a set of techniques that allow you to get the result you need in less code
    - how code can know its own context 
    - how code can know the events in the context
      * when a new class is created
      * when methods gets called
      * when app exit

-----------------------------------------------------------
Chapter 20: Use Hooks to Keep Your Program Informed 249
-----------------------------------------------------------

- Waking Up to a New Subclass 250

  * stay informed to what happened
  * Hook: A Ruby hook is some way — sometimes by supplying a block and sometimes by just overriding a method—to specify the code to be executed when something specific happens.
    - gain a subclass
    - module was included
    - program ready to terminate

  * get to know when a subclass is created:
    - just use 'self.inherited( new_subclass )'
    - maybe useful when you want to create documents for all classes and subclasses

    class SimpleBaseClass
      def self.inherited( new_subclass )
        puts "Hey #{new_subclass} is now a subclass of #{self}!"
      end
    end    

  * example: DocumentReader that has many subclasses, and the 'read' method that can based on each subclass' capacity delegate the call to appropriate subclasses

    class DocumentReader

      class << self
        attr_reader :reader_classes
      end

      @reader_classes = []

      def self.read(path)
        reader = reader_for(path)
        return nil unless reader
        reader.read(path)
      end

      def self.reader_for(path)
        reader_class = DocumentReader.reader_classes.find do |klass|
          klass.can_read?(path)
        end
        return reader_class.new(path) if reader_class
        nil
      end

      # One critical bit omitted, but stay tuned...
      def self.inherited(subclass)
        DocumentReader.reader_classes << subclass
      end

    end

- Modules Want To Be Heard Too 253

  * for modules, the included is the method to hook/monitor module inclusion
    (for modules extension (becomes class methods) use 'extended')

    module WritingQuality
      def self.included(klass)
        puts "Hey, I've been included in #{klass}"
      end
      def self.extended(klass)
        puts "Hey, I've been extended in #{klass}"
      end
      def number_of_cliches
        # Body of method omitted...
      end 
    end

  * how to have both instance method and class method

    module UsefulInstanceMethods
      def an_instance_method
      end
    end

    module UsefulClassMethods
      def a_class_method
      end
    end

    class Host
      include UsefulInstanceMethods
      extend UsefulClassMethods
    end

  * include and extend in one go:

    module UsefulMethods
      module ClassMethods
        def a_class_method
    end end
      def self.included( host_class )
        host_class.extend( ClassMethods )
    end
      def an_instance_method
      end
      # Rest of the module deleted...
    end
    class Host
      include UsefulMethods
    end  

- Knowing When Your Time Is Up 255

  * at_exit 
    - the last chance to insert code before app existing
    - instead of override it, provide/register code block

    at_exit do
      puts "Have a nice day."
    end

    - you can provide multiple code blocks by calling at_exit multiple times
    - last register, first called

- . . . And a Cast of Thousands 256

  * other hooks
    - method_missing
    - method_added
    - trace_var
      (tracking value changes of global variables)
    - most powerful set_trace_func
      * supply a block
      * trace whenever a method is called or returns
      * whenever a class definition is opened with class keyword, or closed with end
      * whenever a exception is raised
      * whenever a line of code is executed

      proc_object = proc do |event, file, line, id, binding, klass|
        puts "#{event} in #{file}/#{line} #{id} #{klass}"
      end
      set_trace_func(proc_object)
      require 'date'

- Staying Out of Trouble 257

  * inherited
    - same file or separated files, all class .... end subclass defnition will trigger
    - for deeper hierarchy, all subclasses will trigger

  * at_exit
    - if Ruby is halfed, it will not get called

- In the Wild 259

  * Test::Unit
    how all test code got executed?
    by providing at_exit code block


    at_exit do
      unless $! || Test::Unit.run?
        exit Test::Unit::AutoRunner.run
      end
    end

    - check $! if there is any error (syntax error)
    - check Test::Unit.run? to make sure the tests are not being executed

- Wrapping Up 261

  * look at serveral hooks in ruby
    - inherited
    - included
    - at_exit

-----------------------------------------------------------
Chapter 21: Use method_missing for Flexible Error Handling 263
-----------------------------------------------------------

  * error handling
    - should have a default behavior
    - should allow easy alteration of the handling behavior
  * method_missing
    - a mechanism to handle method call that does not exist
    - how to customize
  * const_missing
    - how to use it

- Meeting Those Missing Methods 264

  * when calling a non-existing method on an object
    - the Ruby will try to call in current class and all parent classes
    - if nothing found, Ruby will try to call 'method_missing' method
    - the error we see is actually the default behavior of 'method_missing' in the 'Object' class that raised the 'NameError' exception

    class Document
      def method_missing (method_name, *args)
        puts "try to call a non-existing method : #{method_name}"
        puts "with args: #{args.join(' ')}" 
      end
    end

- Handling Document Errors 266

  * you can provide a default method_missing error message for your class

    class Document
      # Most of the class omitted...
      def method_missing( method_name, *args )
        msg =  %Q{
          You tried to call the method #{method_name}
           on an instance of Document. There is no such method.
        }
        raise msg 
      end
    end

  * or just bubble it up for super class to handle (maybe with some logging)

    class Document
      # Most of the class omitted...
      def method_missing( method_name, *args )
        File.open( 'document.error', 'a' ) do |f|
          f.puts( "Bad method called: #{method_name}" )
          f.puts( "with #{args.size} arguments" )
        end
        super 
      end
    end

  * or even be fancy and provide help to the caller

    require 'text'  # From the text gem
    class Document
      include Text
        # Most of the class omitted...
      def method_missing( missing, *args )
        candidates = methods_that_sound_like( missing.to_s )
        message = "You called an undefined method: #{missing}."
        unless candidates.empty?
          message += "\nDid you mean #{candidates.join(' or ')}?"
        end
        raise raise NoMethodError.new( message )
      end
      def methods_that_sound_like( name )
        missing_soundex = Soundex.soundex( name.to_s )
        public_methods.sort.find_all do |existing|
          existing_soundex = Soundex.soundex( existing.to_s )
          missing_soundex == existing_soundex
        end
      end 
    end

- Coping with Constants 267

  * what is constant?
    - CONSTANT_NAME
    - Document::CONSTANT_NAME

    def self.const_missing( const_name ) 
      msg = %Q{
        You tried to reference the constant #{const_name}
        There is no such constant in the Document class.
      }
      puts msg
      #raise msg 
    end

- In the Wild 268

  * 'whiny nil'
    - to solve the problem of checking nil
    - if you accidentally have a nil object 
    - when you try to do anything on the nil object, you will see the error
  * Rails handle 'whiny nil'
    - providing more friendly error message
    - provide reasons
  * Rake use 'const_missing' for obsolete variables
    - by helpfully delegate to the correct method
    - by providng a warning message
  * Rails also use 'const_missing' to load Ruby class as needed

    def self.const_missing( name )
      file_name = "#{name.to_s.downcase}"
      require file_name
      raise "Undefined: #{name}" unless const_defined?(name)
      const_get(name)
    end

- Staying Out of Trouble 270

  * don't use it unless you need it
  * if you call something non_existing within method_missing, it will become infinite loop
  * do more testing

- Wrapping Up 271

  * method_missing and const_missing
  * method_missing is not only for error handling, can be used for delegating

-----------------------------------------------------------
Chapter 22: Use method_missing for Delegation 273
-----------------------------------------------------------

  * imporatnce of 'delegation'
  * how to use method_missing for delegation

- The Promise and Pain of Delegation 274

  * what is delegation in code?
    - one object holding another object
    - all method calls to the first object will in turns call second object
  * traditionally we use some kind of 'wrapper'

    class SuperSecretDocument
      def initialize(original_document, time_limit_seconds)
        @original_document = original_document
        @time_limit_seconds = time_limit_seconds
        @create_time = Time.now
      end
      def time_expired?
        Time.now - @create_time >= @time_limit_seconds
      end
      def check_for_expiration
        raise 'Document no longer available' if time_expired?
      end
      def content
        check_for_expiration
        return @original_document.content
      end
      def title
        check_for_expiration
        return @original_document.title
      end
      def author
        check_for_expiration
        return @original_document.author
      end
      # and so on...
    end

  * the new wrapper check if the time expired? if not then delegate to the original doc

- The Trouble with Old-Fashioned Delegation 275

  * wrapper's problem
    - all methods need to be replicated in wrapper and original obj
    - tightly coupling

- The method_missing Method to the Rescue 277

  * instead of mapping methods one by one

  def method_missing(name, *args)
    check_for_expiration
    @original_document.send(name, *args)
  end

  * send can be used to get around 'public/private' restriction
  * even if the user mistype a method name, it is still captured by the original doc
  * this class can also be used as a 'generic' wrapper, this is really useful  

- More Discriminating Delegation 278

  * if want to restrict which methods to delegate

    class SuperSecretDocument
      # Lots of code omitted...
      DELEGATED_METHODS = [ :content, :words ]
      def method_missing(name, *args) check_for_expiration
        if DELEGATED_METHODS.include?( name )
          @original_document.send(name, *args)
        else
          super 
        end
      end 
    end

- Staying Out of Trouble 279

  * one gotcha, there are methods inherited from Object that the wrapper will have and so will not trigger method_missing
  * to avoid it, use the bare primitive BasicObject which does not have any methods
    - but this require some minor code change since you don't enjoy some Object goodness too

- In the Wild 281

  * the delegate.rb file in standard library provide many classes for generic wrapper/degator
  * simple delegator

    require 'delegate'
    class DocumentWrapper < SimpleDelegator
      def initialize( real_doc )
        super( real_doc )
      end
    end

  * ActiveRecord use method_missing to delgate to datbase actions
    - User.first_name will use method_missing to find value
    - new ActiveRecord enhance it and create the method dynamically, so subsequent calls will not go through method_missing
  * for Ruby 1.8, use 'blankslate' gem instead of 'BasicObject'

- Wrapping Up 283

  * use method_missing for delegation

-----------------------------------------------------------
Chapter 23: Use method_missing to Build Flexible APIs 285
-----------------------------------------------------------

  * it's difficult to provide/design a good interface for your API
  * API interface
    - methods and args
    - how to call them
    - using 'method_missing' to design a flexible API
    - allow users to make up method names for their own uses

- Building Form Letters One Word at a Time 286

  * example: replace content with template

    class FormLetter 
      attr_accessor :content

      def replace_word( old_word, new_word )
        @content.gsub!( old_word, "#{new_word}" )
      end

    end  


- Magic Methods from method_missing 287

  * use method missing to handle it
    - only handle missing method starts with 'replace_'
    - if not 'replace_', call super to let the default method_missing handles it
  * this technique is also called 'magic method'

    class FormLetter 
      attr_accessor :content

      def replace_word( old_word, new_word )
        @content.gsub!( old_word, "#{new_word}" )
      end


      def method_missing( name, *args )
        string_name = name.to_s
        return super unless string_name =~ /^replace_\w+/
        old_word = extract_old_word(string_name)
        replace_word( old_word, args.first )
      end

      def extract_old_word( name )
        name_parts = name.split('_')
        name_parts[1].upcase
      end

    end

- It’s the Users That Count—All of Them 289

  * why doing flexible API work?
    - make code easy to read and write

- Staying Out of Trouble 289

  * be aware of possible name collision
  * consider to rewrite respond_to? to reflect the fact that the class now respond to these API methods

- In the Wild 290

  * OpenStruct class
    - blend of simple data container and hash
    - allow to use obj.xxx = yyyy syntax

    require 'ostruct'
    author = OpenStruct.new
    author.first_name = 'Stephen'
    author.last_name = 'Hawking'
    puts author.first_name
    puts author.last_name

  * how OpenStruct is implemented:
    - if method name ends with '=', it is a setter
    - if method name does not end with '=', it is a getter

    def method_missing(mid, *args) # :nodoc:
      mname = mid.id2name
      len = args.length
      if mname =~ /=$/
        # Some error handling deleted... 
        mname.chop! 
        self.new_ostruct_member(mname) 
        @table[mname.intern] = args[0]
      elsif len == 0
        @table[mid]
      else
        raise NoMethodError,
          "undefined method `#{mname}' for #{self}", caller(1)
      end
    end

  * ActiveRecord::Base
    - find_by_xxxxx
    - find_by_xxxxx_and_yyyyy
    - very flexible

- Wrapping Up 292
  
  * virtual methods:
    - using method_missing to capture the methods
    - parse the requested method name and handle it 

-----------------------------------------------------------
Chapter 24: Update Existing Classes with Monkey Patching 293
-----------------------------------------------------------

  * open class
  * you can change the behavior of any class at any time
    - add methods
    - change code of methods
    - delete method
  * controversial
    - but very practical and useful

- Wide-Open Classes 294

  * the first time you define a class --> the class is created
  * the second time you define a class --> you modify (add methods) class
  * the added methods are available to all objects, even it is instantiate before the modification

- Fixing a Broken Class 295

  * you can also modify the existing methods
    (last defined wins)
  * NaN (caused by divided by zero) example
  * modify methods on the fly is called 'Monkey Patching'

- Improving Existing Classes 296

  * example: handle string + Document
    - so we can have 'some content' + doc to return a new document object
    - existing string's '+' needs to be preserved 

  class String
    def +( other )
      if other.kind_of? Document
        new_content = self + other.content
        return Document.new(other.title, other.author, new_content)
      end
      result = self.dup
      result << other.to_str
      result
    end 
  end

- Renaming Methods with alias_method 297

  * use alias_method to capture the existing method before 'monkey patching' it

    class String
      alias_method :old_addition, :+
      def +( other )
        if other.kind_of? Document
          new_content = self + other.content
          return Document.new(other.title, other.author, new_content)
        end
        old_addition(other)
      end 
    end

- Do Anything to Any Class, Anytime 299

  * there are other things you can do to an existing class
  * public to private or private to public

  class Document
    private :word_count
  end

  class Document
    public :word_count
  end

  * even remove the method

  class Document
    remove_method :word_count
  end

- In the Wild 299

  * Pathname class
    - a very large class
    - separated out into nine places using open class technique
  * Just to make built-in classes more friendly for certain scenarioes
    - ActiveSupport
    - in web programming, we need to test blank string

    class String #:nodoc:
      def blank?
        self !~ /\S/
      end
    end

    - or need to squish consecutive empty spaces in a string

    module ActiveSupport #:nodoc:
      module CoreExtensions #:nodoc:
        module String #:nodoc:
          module Filters
            # Some code deleted...
            def squish!
              strip!
              gsub!(/\s+/, ' ')
              self 
            end
          end 
        end
      end 
    end

    ...

    class String
      # Lots of stuff deleted...
      include ActiveSupport::CoreExtensions::String::Filters
    end

  * ActiveRecord
    - you can call first/second/third/ ...

- Staying Out of Trouble 303

  * possiblity of name collision (accidentally overwrite or be overwritten)
  * know what you are doing and run tests
  * be extra-cautious on basic/fundamental classes such as string

Wrapping Up 303

  * there are other ways to modify a class

-----------------------------------------------------------
Chapter 25: Create Self-Modifying Classes 305
-----------------------------------------------------------

  * how does classes in Ruby got defined?
  * build classes that can programmatically modify itself

- Open Classes, Again 305

  * in ruby, class code is executable
  * when ruby see class XXX, it creates the class
  * when ruby see def ...., it creates methods

- Put Programming Logic in Your Classes 308

  * class can make run-time decisions about what methods to define and what is the code in each method
    - ENCRYPTION_ENABLED is defined run_time

    class Document
      # Lots of code omitted...
      def save( path )
        File.open( path, 'w' ) do |f|
          f.puts( encrypt( @title ))
          f.puts( encrypt( @author ) )
          f.puts( encrypt( @content ))
        end 
      end

      if ENCRYPTION_ENABLED
        def encrypt( string )
          string.tr( 'a-zA-Z', 'm-za-lM-ZA-L')
        end
      else
        def encrypt( string )
          string 
        end
      end 
    end

 
- Class Methods That Change Their Class 309

  * use Class Methods to dynamically define methods
    - use the fact that 'self' refer to the class in Class Methods

    class Document
       # Most of the class left behind...
      def self.enable_encryption( enabled )
        if enabled
          def encrypt_string( string )
            string.tr( 'a-zA-Z', 'm-za-lM-ZA-L')
          end 
        else
          def encrypt_string( string )
            string
          end 
        end
      end
      enable_encryption( ENCRYPTION_ENABLED )
    end

- In the Wild 310

  * handling different version of Ruby environments
    - use built-in RUBY_VERSION

    class Document
      # Lots of stuff omitted...
      if RUBY_VERSION >= '1.9'
        def char_at( index )
          @content[ index ]
        end
      else
        def char_at( index )
          @content[ index ].chr
        end
      end 
    end

  * Rails reloading mechanism
    - 'load' is supplied by Rails that will reload the file itself
      (require will only load the class if not already loaded)
    - __FILE__: provided by Ruby, the file that defines the class itself
    - 'remove_instance_methods' to remove all previous defined methods

    class Document
      def self.reload
        remove_instance_methods
        load( __FILE__ )
      end
      def self.remove_instance_methods
        instance_methods(false).each do |method|
          remove_method(method)
        end
      end      
      # Rest of the class omitted...
    end

- Staying Out of Trouble 314

  * since we conditionally execute dynamic definition of classes
    if there is any exception during the code, it will cause unexpected behavior
  * need testing

- Wrapping Up 315

  * Ruby class are just executable code
  * you can insert logic in class definition

-----------------------------------------------------------
Chapter 26: Create Classes That Modify Their Subclasses 317
-----------------------------------------------------------

  * importance of being lazy
  * put the class modifying code into super-class
  * increase metaprogramming power

- A Document of Paragraphs 317

  * example: a document/paragraph 

    class Paragraph
      attr_accessor :font_name, :font_size, :font_emphasis
      attr_accessor :text
      def initialize( font_name, font_size, font_emphasis, text='')
        @font_name = font_name
        @font_size = font_size
        @font_emphasis = font_emphasis
        @text = text
      end
      def to_s
        @text
      end
      # Rest of the class omitted...
    end

    class StructuredDocument
      attr_accessor :title, :author, :paragraphs
      def initialize( title, author )
        @title = title
        @author = author
        @paragraphs = []
        yield( self ) if block_given?
      end

      def <<( paragraph )
        @paragraphs << paragraph
      end

      def content
        @paragraphs.inject('') { |text, para| "#{text}\n#{para}" }
      end

      # ... 
    end  

    russ_cv = StructuredDocument.new( 'Resume', 'RO' ) do |cv|
      cv << Paragraph.new( :nimbus, 14, :bold, 'Russ Olsen' )
      cv << Paragraph.new( :nimbus, 12, :italic, '1313 Mocking Bird Lane') 
      cv << Paragraph.new( :nimbus, 12, :none, 'russ@russolsen.com')
    end

    pp russ_cv.content

- Subclassing Is (Sometimes) Hard to Do 319

  * start to create subclasses
    - all helper methods are repetitive

    class Resume < StructuredDocument 
      def name( text )
          paragraph = Paragraph.new( :nimbus, 14, :bold, text )
          self << paragraph
      end
      def address( text )
        paragraph = Paragraph.new( :nimbus, 12, :italic, text ) 
        self << paragraph
      end
      def email( text )
        paragraph = Paragraph.new( :nimbus, 12, :none, text ) 
        self << paragraph
      end
      # and so on 
    end

    russ_cv = Resume.new( 'russ', 'resume') do |cv|
      cv.name( 'Russ Olsen' )
      cv.address( '1313 Mocking Bird Lane' )
      cv.email( 'russ@russolsen.com' )
      # Etc... 
    end

- Class Methods That Build Instance Methods 321

  * try to take out the repetitiveness in the above example
    - use more declarative way to define class 
    - the 'paragraph_type' is defined in super class
    - super class's 'paragraph_type' will then create methods for the subclasses

    class Instructions < StructuredDocument
      paragraph_type( :introduction,
        :font_name => :arial,
        :font_size => 18,
        :font_emphasis => :italic )
      # And so on...

      def self.paragraph_type(paragraph_name, options)
      end
    end

  * you can not use 'def method_name' since the method_name is dynamic in this case
  * 'class_eval'
    - a way to evaluate text at run-time
    - in this case, 'self' is set to whichever class that calls 'paragraph_type'. In this case, it is the subclass

    class StructuredDocument
      def self.paragraph_type( paragraph_name, options )
        name = options[:font_name] || :arial
        size = options[:font_size] || 12
        emphasis = options[:font_emphasis] || :normal
        code = %Q{
          def #{paragraph_name}(text)
            p = Paragraph.new(:#{name}, #{size}, :#{emphasis}, text)
            self << p 
          end
        }
        class_eval( code )
      end
      # ... 
    end


- Better Method Creation with define_method 324

  * 'define_method' 
    - 'class_eval' is too broad and may include possiblity of bad code
    - 'define_method' is here to rescue: 
      call with a name and a code block, the parameters are part of the code block

    class StructuredDocument
      def self.paragraph_type( paragraph_name, options )
        name = options[:font_name] || :arial
        size = options[:font_size] || 12
        emphasis = options[:font_emphasis] || :none

        define_method(paragraph_name) do |text|
          paragraph = Paragraph.new( name, size, emphasis, text )
          self << paragraph
        end 

      end
      # ... 
    end

- The Modification Sky Is the Limit 324

  * it is possible to modify the visibility of variables in subclass

    class StructuredDocument
      # Rest of the class omitted...
      def self.privatize
        private :content
      end 
    end

  * with this method, subclass can just call 'privatize' to set the :content variable to private.
  * you can do other things in a class

- In the Wild 327

  * there are a lot of Ruby features implemented with this
    - attr_accessor, attr_reader, attr_writer

    class Printer
      attr_accessor :name
    end

    class Printer
      def name
        @name 
      end
      def name=(value)
        @name = value
      end 
    end

  * ActiveRecord use modifying subclass technique too

    class Automobile > ActiveRecord::Base
      has_one :manufacturer
    end
    my_car  = Automobile.find( :first )
    my_car.manufacturer

  * forwardable.rb
    (similar to delegate.rb, but actually create the methods for you)

    class DocumentWrapper
      extend Forwardable

      def_delegators  :@real_doc, :title, :author, :content
      def initialize( real_doc )
        @real_doc = real_doc
      end 
    end

    real_doc = Document.new( 'Two Cities', 'Dickens', 'It was...' )
    wrapped_doc = DocumentWrapper.new( real_doc )
    puts wrapped_doc.title
    puts wrapped_doc.author
    puts wrapped_doc.content

    - implementation: string based module_eval

    module Forwardable
      # Lots of code deleted...
      def def_instance_delegator(accessor, method, ali = method)
        str = %{
          def #{ali}(*args, &block)
            #{accessor}.__send__(:#{method}, *args, &block)
          end 
        }
        module_eval(str, __FILE__, line_no)
      end
    end

- Staying Out of Trouble 330

  * not easy to grasp and feel comfortable to use
  * keep your goal clear
  * know when things happen
  * pay attention to the value of 'self'
    - in superclass
    - in subclass
    - or in subclass's instance
  * balance of when to use 'metaprogramming'
    - hooks, allow you to respond to events
    - method_missing
    - open class
    - create method on the fly

- Wrapping Up 332

  * in Ruby, classes are not pre-fixed, you can change it just as easy as code
  * Ruby can make your syntax as customized and friendly as possible

===========================================================
PART IV: Pulling It All Together 333
===========================================================

-----------------------------------------------------------
Chapter 27: Invent Internal DSLs 335
-----------------------------------------------------------

Little Languages for Big Problems 335
Dealing with XML 336
Stepping Over the DSL Line 341
Pulling Out All the Stops 344
In the Wild 345
Staying Out of Trouble 347
Wrapping Up 349

-----------------------------------------------------------
Chapter 28: Build External DSLs for Flexible Syntax 351
-----------------------------------------------------------

The Trouble with the Ripper 352
Internal Is Not the Only DSL 353
Regular Expressions for Heavier Parsing 356
Treetop for Really Big Jobs 358
Staying Out of Trouble 360
In the Wild 362
Wrapping Up 364

-----------------------------------------------------------
Chapter 29: Package Your Programs as Gems 367
-----------------------------------------------------------

Consuming Gems 367
Gem Versions 368
The Nuts and Bolts of Gems 369
Building a Gem 370
Uploading Your Gem to a Repository 374
Automating Gem Creation 375
In the Wild 376
Staying Out of Trouble 377
Wrapping Up 380

-----------------------------------------------------------
Chapter 30: Know Your Ruby Implementation 381
-----------------------------------------------------------

A Fistful of Rubies 381
MRI: An Enlightening Experience for the C Programmer 382
YARV: MRI with a Byte Code Turbocharger 385
JRuby: Bending the “J” in the JVM 387
Rubinius 388
In the Wild 389
Staying Out of Trouble 389
Wrapping Up 390

-----------------------------------------------------------
Chapter 31: Keep an Open Mind to Go with Those Open Classes 391
-----------------------------------------------------------

Appendix: Going Further 393