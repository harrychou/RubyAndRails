Eloquent Ruby Note

===========================================================
PART I: The Basics 1
===========================================================

-----------------------------------------------------------
Chapter 1: Write Code That Looks Like Ruby 3
-----------------------------------------------------------

- use two spaces, never tabs

class Document
  attr_accessor :title, :author, :content

  def initialize(title, author, content) 
    @title = title
    @author = author
    @content = content
  end

  def words
    @content.split
  end 

  def word_count
    words.size 
  end
end

- oneliner comment is OK, if it adds more info

  return 0 if divisor == 0 # Avoid division by zero

- camels for Classes, snakes everywhere else
  
  * for constant:
  ALL_UPPER_CASE = 2

- parentheses? optional, but sometimes forbidden

  * most Ruby programmer do use parenthesis
  * but not for simple or common function calls, or calls without parameters

  puts 'Hello Word'

  def words
    @content.split
  end 

  * generally, don't use parenthesis for conditions in control statements

  if word.size > 100
    puts 'too long'
  end

- use semicolon to cram up multiple lines

  * generally, don't do it
  * only do it for simple places

  def method_to_be_overriden; end

- for code blocks (code between braces or use do ... end) 

  * for simeple one line code block, just fold it 

  10.times { |n| puts "The number is #{n}" }

  * for more than one line code block, use do ... end 
  
  10.times do |n|
    puts "The number is #{n}"
    puts "Twice the number is #{n*2}"
  end

-----------------------------------------------------------
Chapter 2: Choose the Right Control Structure 17
-----------------------------------------------------------

- If, Unless, While, and Until 17
  
  * if this then do that
  * do this unless that

  * 'if' is revers of 'unless'
    - 'if not xxx' is the same as 'unless xxx'
    - unless sometimess take less mental energy to process

  * if <--> unless
    while <--> until
  * ruby uses every opportunities to improve the 'readability' of the code

- Use the Modifier Forms Where Appropriate 19

  * do_something if xxx
  * do_something unless xxx
  * do_something while xxx
  * do_something until xxx
  * this is call 'Modifier form'

- Use each, Not for 20

  * in other languages, we use 'for'; for ruby, use 'each'

  fonts = [ 'courier', 'times roman', 'helvetica' ]

  for font in fonts
    puts font
  end  

  # same as
  fonts.each { |font| puts font }
  # or
  fonts.each do |font| 
    puts font 
  end

  * Ruby actually defines the for loop in terms of the each method:

- A Case of Programming Logic 21

    # used as switch statement
    title = 'Clean Code'
    case title
    when 'War And Peace'
      puts 'Tolstoy'
    when 'Romeo And Juliet'
      puts 'Shakespeare'
    else
      puts "Don't know"
    end

    # used to assign value
    author = case title
             when 'War And Peace'
               'Tolstoy'
             when 'Romeo And Juliet'
               'Shakespeare'
             else
               "Don't know"
             end
    expect(author).to eq("Don't know")

    # meke it more compact
    author = case title
             when 'War And Peace' then 'Tolstoy'
             when 'Romeo And Juliet' then 'Shakespeare'
             else "Don't know"
             end 

  * case statement use === for comparison, so it can be used for identify instances

    obj = SomeClass.new
    
    case obj
    when SomeClass
      puts 'it is RubySyntax'
    else 
      puts 'no no ...'         
    end

  * case statement to detect regular expression match

    case title
    when /War And .*/
      puts 'Maybe Tolstoy?'
    when /Romeo And .*/
      puts 'Maybe Shakespeare?'
    else
      puts 'Absolutely no idea...'
    end


- Staying Out of Trouble 23

  * in Ruby, only false and nil are treated as false
  * even empty space, the string 'false' and 0 are 'truthy'
  * even a variable is 'truthy', you cannot compare it to true
    do_something if flag == true
    vs. do_something if flag
  * on the other hand, if you are testing for nil or false, be explcit
    if something.nil?
      ...
    end

- In the Wild 25

  * to initialize something if it is nil, use ||=
    @first_name = '' unless @first_name
    is the same as
    @first_name ||= ''
    which is
    @first_name = @first_name || ''
  * ||= has the danger of overwrite the value if the value is false
    it is looking for nil, but accidentally triggered by false
  * Don’t try to use ||= to initialize things to booleans

-----------------------------------------------------------
Chapter 3: Take Advantage of Ruby’s Smart Collections 29
-----------------------------------------------------------

  * hashes and arrays
  * set is a collection of unordered values with no duplicates

- Literal Shortcuts 29

  * use %w{...} for arrays
    poem_words = [ 'twinkle', 'little', 'star', 'how', 'I', 'wonder' ]
    is the same as
    poem_words = %w{ twinkle little star how I wonder }
  * use hash rockets => for hash
    freq = { "I" => 1, "don't" => 1, "like" => 1, "spam" => 963 }
  * for most case, the key is symbol instead of string
    book_info = { :first_name => 'Russ', :last_name => 'Olsen' }
    or even simpler
    book_info = { first_name: 'Russ', last_name: 'Olsen' }

- Instant Arrays and Hashes from Method Calls 30

  * create/retrieve collections from method call

    def take_all_args ( *args )
      args
    end

    def take_at_least_two( first_arg, *middle_args, last_arg )
      [first_arg] + middle_args + [last_arg]
    end

  * splat: “splat names” , use *args instead of args
    the caller don't have to specify the array

    method_call 'one', 'two', 'three'

    instead of 

    method_call ['one','two','three']

  * splat can work the other way
    when calling a method (arg1, arg2, arg3) with args = ['one', 'two', 'three']

    method_call(*args)

  * for method taking a hash

    def load_font( specification_hash )
      # Load a font according to specification_hash[:name] etc.
    end

    you can call with hash

    load_font( { :name => 'times roman', :size => 12 })

    or, because the last arg is a hash

    load_font( :name => 'times roman', :size => 12 )

    even simpler (common in Rails)

    load_font :name => 'times roman', :size => 12 

- Running Through Your Collection 33

  * use each instead of for
  * for hash
    movie = { title: '2001', genre: 'sci fi', rating: 10 }
    movie.each { |entry| pp entry } #pp is pretty-print
    or
    movie.each { |name, value| puts "#{name} => #{value}"}
  * Array API has very extensive methods, such as
    - find_index
    def index_for( word )
      words.find_index { |this_word| word == this_word }
    end
    - map: transforming the contents of a collection
en mass
      lower_case_words = doc.words.map { |word| word.downcase }
    - inject: in addition to each element, you get the current result
      from this: 
      def average_word_length
        total = 0.0
        words.each { |word| total += word.size }
        total / word_count
      end
      to this: 
      def average_word_length
        total = words.inject(0.0){ |result, word| word.size + result}
        # 0.0 is the initial value of result
        total / word_count
      end

- Beware the Bang! 36

  * some array method change the current instance, while some methods return a new instance
  * methods with ! signals that it will change the current instance
    - reverse vs. reverse!
    - sort vs. sort!
  * in general, method names end with ! means 'dangerour or unexpected result'

- Rely on the Order of Your Hashes 38

  * Ruby arrays and hashes are both ordered.
  * adding an item to hash will add to the end of the array

- In the Wild 38

  * ruby try to use simple collections instead of a new class
  * call File.readlines(file_path) gets a simple array full of strings.
  * XmlSimple gem : use simple collection to represent Xml data
    require 'xmlsimple'
    data = XmlSimple.xml_in('dc.xml')

- Staying Out of Trouble 40

  * don't change the collection (delete or add elements) while traversing elements
  * this will instantly created 24,602 new elements of array, most of them set to nil
    array = []
    array[24601] = "Jean Valjean"
  * choose the right collection for the job
    require 'set'
    word_set = Set.new( words )
  
- Wrapping Up 42

-----------------------------------------------------------
Chapter 4: Take Advantage of Ruby’s Smart Strings 43
-----------------------------------------------------------

- Coming Up with a String 44

  * single quote : limited
  * double quote
    - can insert special characters such as \t \n
    - interpolation #{...}
  * %q{...} %q(...) or %q<...>
  * %Q .... will behave more like double quote
  * all literal strings can span multiple lines
    - to avoid being interpreted as new line use \
  * here document

- Another API to Master 47

  * String API methods
    - chomp: take out one newline charater from the end
    - chop : take out one character
    - upcase, downcase, swapcase
    - sub and gsub (global)
      'It is warm outside'.sub( 'warm', 'cold' )
    - split : turn string into word array
    - index
  * most methods return new string, but adding ! will alter the current string

- The String: A Place for Your Lines, Characters, and Bytes 49

  * each_char : get each char one at a time
  * each_byte : get each char as byte
  * each_line : get each line one at a time
  * since each can mean a lot of thing, String does not have 'each' method

- In the Wild 50

  * string manipulation is everywhere
    - html_escape in RSS library make a string suitable for HTML or XML
  * Rails use string processing to intelligently know when to infer CamelCase or snake_case
  * also Rails use gsub for pluraization of words

- Staying Out of Trouble 51

  * Ruby string is mutable, so if variable assigned, it still point to the same string
    - try to create a new string everytime (use upcase instead of upcase!)
  * take usage of string indexing
    first_name[first_name.size - 1]
    is the same as
    first_name[-1]
    "abcde"[3..4] # => return de

- Wrapping Up 52

-----------------------------------------------------------
Chapter 5: Find the Right String with Regular Expressions 53
-----------------------------------------------------------

  Ruby programmers do A LOT of regular expression

- Matching One Character at a Time 54

  * usually match character by character
  * . will match any single-character string including r and % and ~
  * \. will match .

- Sets, Ranges, and Alternatives 55

  * [0123456789] will match any single digit
  * [0123456789abcdef] will match any single hexadecimal deigit
  * use range
    [0-9a-f] ==> [0-9abcdef] ==> [0123456789abcdef]
    [0-9a-zA-Z_] ==> match any thing alphanumeric plus _
  * other special character
    - \d
    - \w
    - \s any white space space/tab/newline
  * alternative
    - A\.M\.|AM|P\.M\.|PM ==> will match AM/PM/A.M./P.M.

- The Regular Expression Star 57

  * * : zero or more

- Regular Expressions in Ruby 58

  * regular expression literal
    /\d\d:\d\d (AM|PM)/
  * to match
    /\d\d:\d\d (AM|PM)/ =~ '10:24 PM'
    or, '10:24 PM' =~ /\d\d:\d\d (AM|PM)/
    - will return 0, means it matches at the index of zero
    - if no match will return nil
  * to match case insensitively
    puts "It matches!" if /AM/i =~ 'am'
  * a lot of string methods accepts regularexpression as search string
    @content.gsub!( /\d\d:\d\d (AM|PM)/, '**:** **' )

- Beginnings and Endings 60

  * \A begining of text
  * \z end of text
  * ^ : the beginning of the string or the beginning of any line within the string.
  * $
  * to match across multiple like use /m
    /^Once upon a time.*happily ever after\.$/m

- In the Wild 62
  
  * Time class in time.rb
  * zone_offset use regular expression to figure out the timezone
    if /\A([+-])(\d\d):?(\d\d)\z/ =~ zone ... matches stuff like +05 or -05:00 as timezone

- Staying Out of Trouble 63

  * =~
  * return zero means it matches at the beginning of the string

- Wrapping Up 64

-----------------------------------------------------------
Chapter 6: Use Symbols to Stand for Something 65
-----------------------------------------------------------

- The Two Faces of Strings 65

  * Symbols are really just strings
  * a way to do magic string or enum
    book = Book.find(:all)

- Not Quite a String 66

  * string has two meanings:
    - the characters inside
    - the meaning of this specific arrangement of characters
      book = Book.find(:all)
      the :all here give us a special meaning of 'finding all books'
  * if you are using some characters to stand for something in your code, you probably are not very interested in messing with the actual character

- Optimized to Stand for Something 67

  * symbol is optimized to stand for something
  * there can only ever be one instance of any given symbol
    very good for comparison
    a = :all
    b = a
    c = :all    
    # True! All true!
    a == c
    a === c
    a.eql?(c)
    a.equal?(c)
  * symbols are immutable
  * these characters make symbols ideal for hash keys

- In the Wild 69

  * to_s method turn a symbol to string
  * to_sym turns a string to a symbol
  * all objects has a public_methods method
    - returns a list of strings in > Ruby 2
    - returns a list of symbols in < Ruby 2

- Staying Out of Trouble 70

  * Use symbols when you simply want an intelligible thing that stands for something in your code
  * sometimes people will forget to use symbols as hash keys --> always use symbos
    ruby has a HashWithIndifferentAccess class try to mitigate the confusion

- Wrapping Up 71

  * symbols and strings: two siblings with different talents

-----------------------------------------------------------
Chapter 7: Treat Everything Like an Object—Because Everything Is 73
-----------------------------------------------------------

- A Quick Review of Classes, Instances, and Methods 74

  * Class has two purposes
    - a place to define methods
    - a factory to create new instances
  * self : default object for instances
  * don't use self.method if method will do
  * use < for inheritance
    class RomanceNovel < Document
      # Lot's of steamy stuff omitted...
    end
  * all classes are subclasses of Object class

- Objects All the Way Down 76

  * -3.abs
  * "abc".upcase
  * :abc.length
  * /abc/.class --> Regexp
  * true.class --> TrueClass
  * false.class --> FalseClass
  * true.class.class --> Class (eventually class)

- The Importance of Being an Object 77

  * to override a method, just redefine in the subclass
  * eval is defined in Object
    - eval takes a string and execute it 
    - very powerful
  * other methods in Object
    - instance_of?
    - public_methods
    - instance_variables

- Public, Private, and Protected 79

  * by default: all methods are public
    - called everywhere in the program
  * private
    - by putting private in class
    - or by putting private at the bottom of class
    - cannot call a private method with an explicit object reference
    - in Ruby, private methods are callable from subclasses
  * protect 
    Any instance of a class can call a protected method on any other instance of the class.
  * in real Ruby code, visibility is not used quite often
  * even visibility is limited, one can still use 'send' method in Object to invoke private/proted methods
    n = doc.send( :word_count )

- In the Wild 81

  * a lot of ruby code are method calls, private/protected are method call
  * require is a method call that takes the name of file and execute the content of the file
  * other method calls
    - attr_accessor
    - attr_reader
    - attr_writer

- Staying Out of Trouble 82

  * Object class defines 50+ methods
    - these methods can be called everywhere without instance
    - try not to define your methods with the same name, or there will bename collision, such as send/to_s
  * be careful when overriding methods of Object class
  * in Ruby everything is an object (Object class)
    - you don't have to do null handling or special case handling based on types

  a great way to avoid broken code is to have less of it  

- Wrapping Up 84

-----------------------------------------------------------
Chapter 8: Embrace Dynamic Typing 85
-----------------------------------------------------------

  How can you possibly write reliable programs without some kind
of static type checking? And why?

- Shorter Programs, But Not the Way You Think 85

  * allow for more compact code 
    - don't have to specify type
    - don't have to declare variables
    - don't need interface/abstrac_class
    - don't need the casts and d erived types
  * you need to be aware of the possibility and write your code the dynamic typing way
  * duck typing: only care about what an object can do

- Extreme Decoupling 89

  * example: you want to change the type of class's data member
  * you don't have to do anything as long as you don't do anything special about the data members
  * don't do type checking
    - it defeat the purpose of dynamic typing
    - it bloats code
  * “The method is either there or it is not,”

- Required Ceremony Versus Programmer-Driven Clarity 92

  * declaring type sometimes become ceremonial
  * use clarity instead of type declaration to explain

- Staying Out of Trouble 93

  * problems of dynamic typing
    - missing method definition (relax, it is not that bad)
  * try to write your code clear and concise
  * write lots of tests

In the Wild 94

  * “if the method is there, it is the right object”
    
    open_file = File.open( '/etc/passwd' )

    or
    
    require 'stringio'
    open_string = StringIO.new( "So say we all!\nSo say we all!\n" )

    it is coincident that they share some same methods

    - readchar
    - readline
    - seek(n)
  * where subclassing is driven more from practical considerations than considering of type analysis
  * “don’t artificially couple your classes together”
    - in Set class when initialize with Array
    - some code unnecessarily check type of array is Enumerable
    - in face, all you care is if you can call 'each' on it

- Wrapping Up 96

  * First, don’t create more infrastructure than you really need. 
  * Keep in mind that Ruby classes don’t need to be related by inheritance to share a common interface; they only need to support the same methods.
  * Don’t obscure your code with pointless checks to see whether this really is an instance of that. 
  * Do take advantage of the terseness provided by dynamic typing to write code that simply gets the job done with as little fuss as possible—but 
  * Keep in mind that someone (possibly you!) will need to read and understand the code in the future.
  * WRITE A LOT OF TESTS

-----------------------------------------------------------
Chapter 9: Write Specs! 97
-----------------------------------------------------------

  * A key part of the Ruby style of programming is that no class, and certainly no program, is ever done if it lacks automated tests.
  * Two different test framework
    Test::Unit
    RSpec

- Test::Unit: When Your Documents Just Have to Work 98

  * part of xUnit suite
  * require 'test/unit'
  * just run the file as regular ruby file
  * assert_equal and assert
  * use setup and teardown

- A Plethora of Assertions 101

  * assert_match /times.*/, 'times new roman'
  * assert_instance_of String, 'hello'
  * assert that the code raise error
    assert_raise ZeroDivisionError do
      x = 1/0
    end
  * assert that the code does NOT raise error
    assert_nothing_thrown do
      x = 1/2
    end

- Don’t Test It, Spec It! 101

  * test vs. spec
  * spec is about expectation and behavior, not data
  * a spec is something like this: 
    About the Document class: When you have a document instance, it should 
    hang onto the text that you give it. It should also return an array 
    containing each word in the document when you call the words method. 
    And it should return the number of words in the document when you call the word_count method.
  * expect
    expect(...).to eq(...) # test equality
    expect(...).to be(...) # test equality
    expect(...) # test true

- A Tidy Spec Is a Readable Spec 104

  * rspec 
    - it 'behavior' do : describe a behavior
    - before :each do ... : setup 
    - after :each
    - before :all
    - after :all

- Easy Stubs 105

  * how to isolate the class in test without testing supporting classes?
    - stub (a class that has the same interface as the supporting class)
      aka: stand-in class
    - mock
  * rspec make creating stub very easy, you just create a dynamic object with the method implementation (fake ones)
    - stub (create a new object)
      stub_printer = stub :available? => true, :render => nil
    - stub! (modify an existing object/class)
      apparently_long_string = 'actually short'
      apparently_long_string.stub!( :length ).and_return( 1000000 )

- . . . And Easy Mocks 107

  * mock: we need to verify the behavior of the class-in-test
  * A mock is a stub with an attitude (expectations).
    - knowing what canned responses to return
    - knows which methods should be called and with what arguments
    - and how many times
  * example:
    mock_printer = mock('Printer')
    mock_printer.should_receive(:available?).and_return(true)
    mock_printer.should_receive(:render).exactly(3).times
  * http://rspec.info/

- In the Wild 108

  * if using Test::Unit, there are other useful tools
    - shoulda (expectation syntax)
    - mocking (mock)
  * check out RubySpec
    - a spec for Ruby language itself

- Staying Out of Trouble 110

  * keep tests fast
  * tests should communicate clearly where it got failure/errors
  * tests should be silent if no errors
  * tests should be independent of each other
  * fail tests first before you implement
  * some simple tests are better than no tests

- Wrapping Up 113

  * write tests/specs

===========================================================
PART II: Classes, Modules, and Blocks 115
===========================================================

-----------------------------------------------------------
Chapter 10: Construct Your Classes from Short, Focused Methods 117
-----------------------------------------------------------

- Compressing Specifications 117

  * how to create good methods?
  * ruby prefers short and focused methods
  * short methods works great with ruby
  * short methods made code more testable

- Composing Methods for Humans 121

  * example: implementing a text compression class
    - take a string and output two arrays
    - one array is all the unique words
    - second array is the representation of the string using the first array's indexes
  * taking two refactorings:
    - goal is to make short and focused methods

      def unique_index_of( word )
        @unique.index(word)
      end
      def add_unique_word( word )
        @unique << word
        unique.size - 1
      end

    - use ruby to make code clear

      i = unique_index_of( word )
      if i
        @index << i
      else
        @index << add_unique_word( word )
      end

      to use || instead of if... else

      i = unique_index_of( word ) || add_unique_word( word )
      @index << i

- Composing Methods for Human 121

  * The composed method technique advocates dividing your class up into methods that have three characteristics.
    - single responsibility for all code within
    - single conceptual level for all code within
    - clear name 
  * smaller methods are easy-to-comprehend and will help you get the details right.

- Composing Ruby Methods 122

  * short method are good for ruby because it is really easy to create/maintain methods
  * also short methods are easy to test

- One Way Out? 123

  * multiple return places make the code hard to comprehend
  * shorter methods make the code clearn and don't have to worry about multiple returns

- Staying Out of Trouble 126

  * two things to remember about methods
    - short
    - coherent
  * sometimes, try to create short methods only add clutter

- In the Wild 127

  * example: ActiveRecord::Base
    - short with average 9 lines of code
    - good and descriptive names

- Wrapping Up 128

-----------------------------------------------------------
Chapter 11: Define Operators Respectfully 129
-----------------------------------------------------------

- Defining Operators in Ruby 129

  * it is powerful to be able to redefine standard operations
  * Ruby supports
    * plus and risks

  * Ruby's philosophy is to empower programmers, don't keep secret
  * you can define your own Float and have all the standard numeric operators with it
  * Ruby translates operators to corresponding method calls
    result = first + second * (third - fourth)
    ==>
    result = first.+(second.*(third.-(fourth)))

    class Document
      # Most of the class omitted...
      def +(other)
        Document.new( title, author, "#{content} #{other.content}" )
      end
    end

- A Sampling of Operators 131

  * popular operators overloads
    + - / *
    %(mode) & | ^ (exclusive or)
    << (Ruby use this to mean - add another)
    +@ (+ as unary) -@ (- as unary)
  * array operator
    [](index) ==> for retrieving an element obj[3]
    []=(index, obj) ==> for assign an element at location
    - if array operators are defined, better define 'size' so users know the index range

- Operating Across Classes 134

  * if define an operator across classes of objects, it is better to define the same operator for all classes

- Staying Out of Trouble 135

  * when to use operator overloading
    - if your class is a natural candidate for numeric operations
    - if your class is a collection
      - define <<
      - if index is supported [] and []=
  * operators should not modify operands

- In the Wild 137

  * Time can do operations, but not commutative
    Time.now
    one_minute_from_now = now + 60 
  * string class overload %
    "The value of n is %d" % 42
  * RSpec should
    x.should == 42

- Wrapping Up 139

  * equality (== and ===) is totally separate subject

-----------------------------------------------------------
Chapter 12: Create Classes That Understand Equality 141
-----------------------------------------------------------

  object equality is a tough question
  important for creating well-behaved objects

- An Identifier for Your Documents 141

  * create a DocumentIdentifier class to identify Document objects with @name and @folder
  * question: how to compare two DocumentIdentifier objects

- An Embarrassment of Equality 142

  * in Ruby there are four methods for equality
    - eql?
    - equal?
      * for object identify
      * no need to override, ever
    - ==
    - ===

- Double Equals for Everyday Use 143

  * == default behavior is equal?
  * can be overriden

  def ==(other)
    return true if other.equal?(self)
    return false unless other.instance_of?(self.class)
    folder == other.folder && name == other.name
  end 

  * nice, no need to check nil

- Broadening the Appeal of the == Method 145

  * if want to also allow subtypes
    change instance_of? to kind_of?
  * if want to totally don't care about type heirarchy
    use respond_to?

    def ==(other)
      return false unless other.respond_to?(:folder)
      return false unless other.respond_to?(:name)
      folder == other.folder && name == other.name
    end

- Well-Behaved Equality 146

  * be aware of the principla of symmetry
    - if a == b, this should be true too: b == a
  * transive principle
    - if a == b, and b == c
      a == c should be true
  * rethink about overriding ==
    - do we really need to allow == to do that many things?
    - why not make it less smart

- Triple Equals for Case Statements 149

  * === is used when compare in case statement
  * this is to allow this code: 

    location = 'area 51'
    case location
    when /area.*/
      # ...
    when /roswell.*/
      # ...
    else
      # ...
    end

  * the Regexp class implements === that does pattern matching
  * most of the time === is just the same as ==
    ==> better to leave this alone

- Hash Tables and the eql? Method 150

  * implicity called in Hash table situation
  * only needed when your object will be used as Hash key
  * but still not easy, need to have the same hash key

- Building a Well-Behaved Hash Key 152

  * The Hash class calls the hash method (another one of those methods that you inherit from Object) to get the hash code from its keys. The Hash class uses the eql? method to decide if two keys are in fact the same key.
  * override both hash value and eq?

    def hash
      folder.hash ^ name.hash
    end

    def eql?(other)
      return false unless other.instance_of?(self.class)
      folder == other.folder && name == other.name
    end

- Staying Out of Trouble 153

  * don't try to be fancy
    Many objects will never find themselves in the middle of an equality expression or be called upon to be a hash key.
  * if your class is just a wrapper, borrow code

    class DisArray
      attr_reader :my_array
      
      def initialize
        @my_array = []
      end
      def ==(other)
        return false unless other.kind_of?(DisArray)
        @my_array == other.my_array
      end
      def eql?(other)
        return false unless other.kind_of?(DisArray)
        @my_array.eql?( other.my_array )
      end
      def hash
        @my_array.hash
      end

      # Rest of the class omitted...
    end

  * do the simplest thing that might work
    don't try to do cross class equality if you can avoid it

- In the Wild 154

  * in Ruby, integer (FixNum) and Float class can use ==
  * if you define <=>, with Comparable module included
    ==> ruby will implement ==, < <=, ... etc for you

    class RomanNumerals
      include Comparable
  
      # Actual guts of the class omitted...
  
      def <=>(other)
        # Return -1, 0, or 1...
      end
    end

  * <=> should return -1 if a is less than b, 0 if they are equal, and 1 if a is greater than
  * ruby classes (subclass of Class), implement === with kind_of? to allow: 

    the_object = 3.14159
    case the_object
    when String
      puts "it's a string"
    when Float
      puts "It's a float"
    when Fixnum
      puts "It's a fixnum"
    else
      puts "Dunno!"
    end
  * because of the above, you can even write
    Float === 1.0

- Wrapping Up 156

  * getting object equality right can be trying, it is certainly doabl
  * understand the equality model well

Chapter 13: Get the Behavior You Need with Singleton and
Class Methods 157

  * class hierarchy/model is the essential part of OO
  * what do you do when the class/instance approximation breaks down?
    - what to do when the instance does not want to follow the spec of class?
    - singleton method is Ruby's solution
    - class method is just another name of singleton method

- A Stubby Puzzle 158

  * recall Rspec use stub method to create stub objects

  stub_printer = stub :available? => true, :render => nil
  stub_font = stub :size => 14, :name => 'Courier'

  * all stub objects are of class Mock
  * all the stubbed methods (:available?, :render, ... etc) are singleton methods
  * singleton methods
    - methods that are designed for only one object instance
    - how to define?
      (def instance.method_name)

      hand_built_stub_printer = Object.new
      def hand_built_stub_printer.available?
        true
      end
      def hand_built_stub_printer.render( content )
        nil
      end
  * Singleton methods override any regular, class-defined methods. 
  * alternative way to create singleton methods:

    class << hand_built_stub_printer
      def available? # A singleton method
        true
      end
      def render # Another one
        nil
      end
    end

- A Hidden, but Real Class 160

  * how is 'singleton methods' implemented?
  * every Ruby object carries around an additional, somewhat shadowy class of its own
  * called 'singleton class' 
    (or metaclass or eigenclass)
  * how to get hold of 'singleton class'

    singleton_class = class << hand_built_stub_printer
      self
    end

    - 'class << hand_built_stub_printer' changed the context, so 'self' is the singleton class
    - by returning it, the singleton_class vairiable will pont to it

Class Methods: Singletons in Plain Sight 162

  * class methods: methods that are defined in the class
  * ways to define class methods

    def Document.explain
      puts "self is #{self}"
      puts "and its class is #{self.class}"
    end

    class Document
      def self.create_test_document( length )
        Document.new( 'test', 'test', 'test ' * length )
      end
      # ...
    end

    class Document
      class << self
        def find_by_name( name )
          Class Methods: Singletons in Plain Sight 163
          # Find a document by name...
        end
      end
      # ...
    end

  * in essence, class methods are singleton methods
  * just whether the class is the instance's 'singleton class' or the regular 'class' (which is an instance of the class Class)

In the Wild 164

  * in ActiveRecord, table_name is a class method
    
    class Author < ActiveRecord::Base
    end

    my_table_name = Author.table_name

  * use class methods for Factory methods to create new instances of the class

    require 'date'
    xmas = Date.civil( 2010, 12, 25 )
    xmas = Date.commercial( 2010, 51, 6 )

  * obj.singleton_methods will give you a list of singleton methods

Staying Out of Trouble 165

  * be aware of different scope
  * class methods are not visible to instances
  * or, use obj.class.class_method to call it
  * class methods can also be inherited
    (a topic in metaprogramming)

    class Parent
      def self.who_am_i
        puts "self is #{self}"
      end
    end

    class Child < Parent
    end  

    Parent.who_am_i ==> self is Parent
    Child.who_am_i ==> self is Child

Wrapping Up 167

  * signleton method, class method
  * singleton class

Chapter 14: Use Class Instance Variables 169

  * programs deal with data
  * where to store class-level data
    - class variable @@
      (have some undesireable behaviors)
    - class instance variable
      (more practical for use)

- A Quick Review of Class Variables 169

  * using class variable @@
    - not visible outside the class
    - visiable to instances of the class
    - example

      class Document
        @@default_paper_size = :a4

        def self.default_paper_size
          @@default_paper_size
        end

        def self.default_paper_size=(new_size)
          @@default_paper_size = new_size
        end

          attr_accessor :title, :author, :content
          attr_accessor :paper_size
        
        def initialize(title, author, content)
          @title = title
          @author = author
          @content = content
          @paper_size = @@default_paper_size
        end

        # Rest of the class omitted...
      end 

- Wandering Variables 171

  * problem with class variable
    => when resolving the varaible, Ruby travels class hierarchy to know which class
  * for assigning @@default_paper_size = :a4
    - first look at current class
    - if not, look up the hierarchy
    - if run out, create the @@default_paper_size in current class
  * for getter
    - first look at current class
    - if not, look up the hierarchy
    - if run out, throw NameError exception
  * Document, Resume, Presentation class hierarchy
    - end result -> based on the order of require, the class variable will be set/overwrite
  * this is very similar to the 'global variable' problem. 
    Just in this case, the variable is global within the inheritance tree
     
- Getting Control of the Data in Your Class 174

  * instead of using @@, why not use @ at the class instance

    class Document
      @default_font = :times
      
      def self.default_font=(font)
        @default_font = font
      end
  
      def self.default_font
        @default_font
      end
  
      def initialize(title, author)
        @title = title
        @author = author
        @font = Document.default_font
      end      
    end

- Class Instance Variables and Subclasses 175

  * class instance variables do just fine with subclasses
  * child classes can have the same class instance variable

    class Presentation < Document
      @default_font = :nimbus
      class << self
        attr_accessor :default_font
      end
      def initialize(title, author)
        @title = title
        @author = author
        @font = Presentation.default_font
      end
      # most of the class omitted...
    end  

- Adding Some Convenience to Your Class Instance Variables 176

  * to avoid defining getters and setters, use the 'class << self'

    class Document
      # @variables defined here is associated with the class, not instance
      @default_font = :times
    
      class << self
        attr_accessor :default_font
      end
    
      # Rest of the class omitted...
    end

- In the Wild 177

  * Rails use class instance variables to regiter callbacks
    - example: ActiveRecord
    - the call after_save actually keeps the callback function in a class instance variable (defined in ActiveRecord::Base) call @after_save_callbacks

    class Person < ActiveRecord::Base
      after_save :handle_after_save
      def handle_after_save
      # Do something after the record is saved...
      end
    end

  * class variables @@ are still useful 
    - example: URI parsing
    - URI class hold a @@schemes variable
    - every kind of schema will need to add itself to the variable

      class HTTP
        # Lots of code omitted...
      end
      @@schemes['HTTP'] = HTTP

    - @@schema is not only a class variable, it is a 'module variable'

      module URI
        # ...
        @@schemes = {}
      end
      module URI
        class HTTP
          # Lots of code omitted...
        end
        @@schemes['HTTP'] = HTTP
      end

- Staying Out of Trouble 179

  * if class variables are to be used, follow what @@schems does
  * declare the @@schemes early in the module before any other code can access it

- Wrapping Up 179

  * class variables can be confusing
  * class instance variables are there to fill in the role

Chapter 15: Use Modules as Name Spaces 181

  * for larger projects, we need a way to organize things
  * modules is a way to organize the classes and constants (and modules) into a friendly hierarchy

- A Place for Your Stuff, with a Name 181

  * multi-hats of classes
    - factory
    - container
    - methods and constants
    - play in class hierarchy (be super)
  * module is the container part of class without factory
    - cannot be instantiate
    - can hold
      - methods
      - constants
      - classes
      - other modules

      module Rendering
        class Font
          attr_accessor :name, :weight, :size
          def initialize( name, weight=:normal, size=10 )
            @name = name
            @weight = weight
            @size = size
          end
          # Rest of the class omitted...
        end
        class PaperSize
          attr_accessor :name, :width, :height
          def initialize( name='US Let', width=8.5, height=11.0 )
            @name = name
            @width = width
            @height = height
          end
          # Rest of the class omitted...
        end

        DEFAULT_FONT = Font.new( 'default' )
        DEFAULT_PAPER_SIZE = PaperSize.new
      end

  * to access the class inside module 
    - Rendering::Font
    - Rendering::DEFAULT_FONT
  * to avoid typing module names use:
    include Rendering

- A Home for Those Utility Methods 184

  * use Module to hold utility methods
    - defined as self. (module-level methods)
    - calling: WordProcessor.inches_to_points( 1.0 )
    - or (less used) WordProcessor::inches_to_points( 1.0 )

    module WordProcessor
      def self.points_to_inches( points )
        points / 72.0
      end
      def self.inches_to_points( inches )
        inches * 72.0
      end
      # Rest of the module omitted
    end

- Building Modules a Little at a Time 185

  * Ruby's code is always open to extension (modifications)
  * Modules can be defined in two separate files and pull them in together by two requires

- Treat Modules Like the Objects That They Are 186

  * everything is object, including module

    the_module = Rendering
    times_new_roman_font = the_module::Font.new('times-new-roman' )

  * we can use this to swap modules, as long as the two modules support the same functionalities(methods/constants .... (interface))

- Staying Out of Trouble 189

  * when to use namespace modules?
    - when you create a lot of related classes
  * when defining utility methods in modules, make sure use 'self.'
    - if not, the method cannot be used (unless being mixed in to another class)
  * don't nest modules too deep

- In the Wild 190

  * examples:
    - DataMapper
    - YAML

- Wrapping Up 191
  
  * use module to divide up the code
  * module can be used as object too
  * another use of module: as mix-ins

Chapter 16: Use Modules as Mixins 193

  class can be 'super' (play in hierarchy of classes)
  modules can be used to 'inject' (mix-in) into class hierarchy
  mix-in allow you to 'share' common code in unrelated classes

- Better Books with Modules 193
  
  * example: we have two separate class heirarchy
  * you have a piece of code that you want to share among them
  * you can create a super-class and have the two classes both inherit it
  * or, cleaner, use 'mix-in'

- Mixin Modules to the Rescue 195

  * by including a module in a class you have mixed it in to the class. 
  * the module itself, WritingQuality in this case, is a mixin mod- ule. 
  * it is possible, and common, to include multiple modules in a class

- Extending a Module 197

  * instead of mix-in methods to become instance methods
  * use extend to mix-in the methods as singleton class methods

    class Document
      extend Finders
      # Most of the class omitted...
    end

- Staying Out of Trouble 198

  * implementation
    When you mix a module into a class, Ruby rewires the class hierarchy a bit, inserting the module as a sort of pseudo superclass of the class.
  * No matter how many modules a class includes, instances of the class will still claim to be, well, instances of the class.
  * but, you can use kind_of? to find out if an object is from a class that includes certain module
  * or, use ClassName.ancestors to get a list of superclasses and moduels
  * the class can override the methods in the included module
  (since when you include a module, Ruby create an immediate super class on top of the class)
  * if you include multiple modules, each include will bump the other modules up one level
  * when writing modules, think through the interface itneraction between the module and the class - use comment to warn the including class author

- In the Wild 202

  * module can contains all kind of things
    - methods
    - constants
    - ... etc
  * DataMapper is a good example of using module instead of super class
  * helpers
    - in Rails' view helper

    module ActionView
      # Huge amounts of code and helpful documentation omitted...
      module Helpers
        module FormHelper
          def label(object_name, method, text = nil, options = {})
             # ...
          end
          def radio_button(object_name, method, tag_value,options={})
            # ...
          end 
        end
      end
    end

  * constants
    - sqlite3
      
      module ErrorCode
        OK         =  0   # Successful result
        ERROR      =  1   # SQL error or missing database
        INTERNAL   =  2   # An internal logic error in SQLite
        PERM       =  3   # Access permission denied
        ABORT      =  4   # Callback routine requested an abort
        BUSY       =  5   # The database file is locked
        LOCKED     =  6   # A table in the database is locked
        # Seemingly endless list of remaining error codes omitted...
      end

    - by including this module, you can access OK/ERROR/ ... directly  

- Wrapping Up 205

  * use mix-in
  * mix-in will create phantom super class
  * be aware of the interface between module and the including classes

Chapter 17: Use Blocks to Iterate 207

- A Quick Review of Code Blocks 207

  * calling method with code block as argument

    do_something do
      puts "Hello from inside the block"
    end

    do_something { puts "Hello from inside the block" }

  * handling the code block argument

    def do_something
      yield if block_given?
    end  

  * with arguments

    def do_something_with_arg (a, b)
      yield a, b if block_given?
    end

    # calling

    do_something_with_arg do |a, b|
      pp a
      pp b
      puts "Hello from inside the block "
    end

  * code block does return a value

- One Word after Another 209

  * if really wanted, you can define your own eachXX method

    class Document
      # Stuff omitted...
      def each_word
        word_array = words
        index = 0
        while index < words.size
          yield( word_array[index] )
          index += 1
          end
      end
    end

  * but since words is already a collection, why not just use it?

    def each_word
      words.each { |word| yield( word ) }
    end

- As Many Iterators as You Like 210

  * can have multiple iterators
  * you can iterate through as much as possible
  * can give any names

- Iterating over the Ethereal 211

  * you can write iterators that run through collections that don’t actually exist, at least not all at the same time.

    12.times { |x| puts "The number is #{x}" }

  * just need to return something one at a time

    def each_word_pair (words)
      word_array = words
      index = 0
      while index < (word_array.size-1)
        yield word_array[index], word_array[index+1]
        index += 1
      end
    end

    words = ['harry', 'chou', 'rocks', 'yeah']
    each_word_pair words do |first, second|
      puts "#{first}, #{second}"
    end    

- Enumerable: Your Iterator on Steroids 213

  * you can use Enumerable module to enhance your collection class
    - just need to define the each method
  * Enumerable module gives you some methods to use
    - include?
    - to_a (return an array)
    - find
    - find_all
    - each_cons(n)
      repeatedly call the block, each time passing in an array of consecutive elements from the collection
    - each_splice
    - count
    - if <=> defined, can use sort
  * Enumertor
    you can also use Enumerator class to create a enumerable based on any arbitrary eachXX method

    enum = Enumerator.new( doc, :each_character )

- Staying Out of Trouble 215
  
  * block is external to the classes that use it
    - be careful how the block works
    - block can raise exception too
      * use exception handling

        def each_name
          # Get some expensive resource
          name_server = open_name_server 
          
          begin
            while name_server.has_more?
            yield name_server.read_name
            end
          ensure
            # Close the expensive resource
            name_server.close 
          end
        end

    - block can also run slow or never stop
      * use break or return
      * break: 
        break will trigger a return out of the method that called the block.
      * return:
        the method that defined (not called) the block to return
      * both break and return will trigger 'ensure'

- In the Wild 217

  * Dir class use block to iterate over directory

    etc_dir = Dir.new("/etc")
    etc_dir.each {|entry| puts entry}

  * Resolv (find all the IP addrs using DNS)

    require 'resolv'
    Resolv.each_address( "www.google.com" ) {|x| puts x}

  * ObjectSpace.each_object

    ObjectSpace.each_object(String) { |the_string| puts the_string }

  * find all Primes

    require 'mathn'
    # Warning: According to Euclid, this never stops...
    Prime.each {|x| puts "The next prime is #{x}" }

- Wrapping Up 218

  * As long as you can come up with one element after another, you can build an iterator.

Chapter 18: Execute Around with a Block 219

  * use code block to deliver code to other places
  * how to provide data arguments and get return value
  * why method names are important

- Add a Little Logging 219

  * example: adding logging to your code
    - you don't want the logging to be everywhere
    - you don't want to disturb the general flow
    - you can use code block: 

      def do_something
        with_logging('load') { @doc = Document.load( 'resume.txt' ) }
        # Do something with the document...
        with_logging('save') { @doc.save } 
      end

      def with_logging(description)
        begin
          @logger.debug( "Starting #{description}" )
          yield
          @logger.debug( "Completed #{description}" )
        rescue
          @logger.error( "#{description} failed!!")
          raise
        end 
      end

    - this abstract out the begin/rescue/end block and also add logging logic to a central place
    - this also clearly communicate the code

- When It Absolutely Must Happen 224

  * this technique is called 'execution around'
    “bury the details in a method that takes a block” 
  * execute around means you take a block of code and you want to execute something before and/or after executing the code, or even handle exceptions 

- Setting Up Objects with an Initialization Block 225

  * sometimes when designing a class, you want your user to be able to add initialization logic

  def initialize(title, author, content = '')
    @title = title
    @author = author
    @content = content
    yield( self ) if block_given?
  end

- Dragging Your Scope along with the Block 225

  * a common mistake, you unnecessarily pass more data than needed
    - the code block has a closure
    - the variables are dragged along with the code block
  * the time you want to pass in argument to the method is for the containing method to use, not the code block

- Carrying the Answers Back 227

  * sometimes you want to capture the returned value of code block
  * and do something with it

- Staying Out of Trouble 228

  - for 'execute around' code block, the exception handling is important, because you want to ensure something code will happen before/after execution
  - keep the name reasonable for the caller to communicate the code's intent
  

In the Wild 229
Wrapping Up 231

Chapter 19: Save Blocks to Execute Later 233
Explicit Blocks 233
The Call Back Problem 234
Banking Blocks 236
Saving Code Blocks for Lazy Initialization 237
Instant Block Objects 239
Staying Out of Trouble 240
In the Wild 243
Wrapping Up 244

PART III: Metaprogramming 247

Chapter 20: Use Hooks to Keep Your Program Informed 249

- Waking Up to a New Subclass 250

Modules Want To Be Heard Too 253
Knowing When Your Time Is Up 255
. . . And a Cast of Thousands 256
Staying Out of Trouble 257
In the Wild 259
Wrapping Up 261

Chapter 21: Use method_missing for Flexible Error Handling 263
Meeting Those Missing Methods 264
Handling Document Errors 266
Coping with Constants 267
In the Wild 268
Staying Out of Trouble 270
Wrapping Up 271

Chapter 22: Use method_missing for Delegation 273
The Promise and Pain of Delegation 274
The Trouble with Old-Fashioned Delegation 275
The method_missing Method to the Rescue 277
More Discriminating Delegation 278
Staying Out of Trouble 279
In the Wild 281
Wrapping Up 283

Chapter 23: Use method_missing to Build Flexible APIs 285
Building Form Letters One Word at a Time 286
Magic Methods from method_missing 287
It’s the Users That Count—All of Them 289
Staying Out of Trouble 289
In the Wild 290
Wrapping Up 292

Chapter 24: Update Existing Classes with Monkey Patching 293
Wide-Open Classes 294
Fixing a Broken Class 295
Improving Existing Classes 296
Renaming Methods with alias_method 297
Do Anything to Any Class, Anytime 299
In the Wild 299
Staying Out of Trouble 303
Wrapping Up 303

Chapter 25: Create Self-Modifying Classes 305
Open Classes, Again 305
Put Programming Logic in Your Classes 308
Class Methods That Change Their Class 309
In the Wild 310
Staying Out of Trouble 314
Wrapping Up 315

Chapter 26: Create Classes That Modify Their Subclasses 317
A Document of Paragraphs 317
Subclassing Is (Sometimes) Hard to Do 319
Class Methods That Build Instance Methods 321
Better Method Creation with define_method 324
The Modification Sky Is the Limit 324
In the Wild 327
Staying Out of Trouble 330
Wrapping Up 332
PART IV: Pulling It All Together 333

Chapter 27: Invent Internal DSLs 335
Little Languages for Big Problems 335
Dealing with XML 336
Stepping Over the DSL Line 341
Pulling Out All the Stops 344
In the Wild 345
Staying Out of Trouble 347
Wrapping Up 349

Chapter 28: Build External DSLs for Flexible Syntax 351
The Trouble with the Ripper 352
Internal Is Not the Only DSL 353
Regular Expressions for Heavier Parsing 356
Treetop for Really Big Jobs 358
Staying Out of Trouble 360
In the Wild 362
Wrapping Up 364

Chapter 29: Package Your Programs as Gems 367
Consuming Gems 367
Gem Versions 368
The Nuts and Bolts of Gems 369
Building a Gem 370
Uploading Your Gem to a Repository 374
Automating Gem Creation 375
In the Wild 376
Staying Out of Trouble 377
Wrapping Up 380

Chapter 30: Know Your Ruby Implementation 381
A Fistful of Rubies 381
MRI: An Enlightening Experience for the C Programmer 382
YARV: MRI with a Byte Code Turbocharger 385
JRuby: Bending the “J” in the JVM 387
Rubinius 388
In the Wild 389
Staying Out of Trouble 389
Wrapping Up 390

Chapter 31: Keep an Open Mind to Go with Those Open Classes 391

Appendix: Going Further 393